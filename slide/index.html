
<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

        <title>reveal.js</title>

        <link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/black.css">

        <!-- Theme used for syntax highlighting of code -->
        <link rel="stylesheet" href="lib/css/zenburn.css">

        <!-- Printing and PDF exports -->
        <script>
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>
    </head>
    <body>
        <style>
        img {
            border-style:none;
        }
        </style>

        <div class="reveal">
            <div class="slides">
                <section 
                    data-markdown
                    data-separator="^\n<<<$"
                    data-separator-vertical="^\n>>>$">

# パケットを作ろう！
#### 作って学ぶパケット入門

<<<

## 自己紹介

>>>

## あかこう
@akakou_py 

セキュリティが好き。

![](https://pbs.twimg.com/profile_images/811407669894385664/8dQkt863_400x400.jpg)

<<<

## 皆さんは

>>>

## wireshark
## 覗いたことありますか？

>>>

### wireshark
* ネットワークプロトコルアナライザ
* これを使うとパケットが見れる

![](https://cdn-ssl-devio-img.classmethod.jp/wp-content/uploads/2014/08/wireshark_icon.jpg)

>>>

### 初めてwiresharkと出会った僕
「へぇ〜これを使うとパケットが見えるんだぁ〜、すごいなぁ〜」

>>>

# 画面

>>>

### 確かにパケットが見える
## しかし**読めるとは言ってない**

>>>

パケットを読むには
パケットの知識が必要

>>>

#### そこで僕は様々な手段を試しました

* ### 読書
* ### 自作ルータ
* ### 自作パケット

>>>

* ## 自作ルータ
* ## 自作パケット

>>>

* # 自作パケット

>>>

### 自作パケットすごい良かった

* そのパケット持つ値を理解していかないと次に進まない感が良い
* L3、L4のパケットの内容に関してはほとんど理解できる

>>>

### でもこんなところが悪かった

* #### とても辛かった
* #### ある程度知識がないと進まない 


>>>

## 今回は

### 基礎知識をつけながら
### （楽しく？）

パケットを自作を通して、  
パケットについて解説していきたいと思います。

>>>

## 早速やっていきましょう！
![](https://emojipedia-us.s3.amazonaws.com/thumbs/160/apple/129/thumbs-up-sign_1f44d.png)


<<<

## 基礎知識を学ぶ

>>>

### パケットを読むにも、作るにも
### TCP/IPに関する知識が必要です。


>>>
### パケットを詳細に理解する前に、
### TCP/IPについて
### 簡単に復習しましょう。

<<<

## Protocol

>>>

### Protocol（プロトコル）とは

#### 通信をする際のルールや
#### 決まりごと（のようなもの）。  

>>>
### 例を上げるならば
HTTP, FTP, TCP, UDP, IP, IPv6, ARP, Ethernet, IEEE 802.11, PPP

<<<
## OSI参照モデル

>>>
### OSI参照モデルとは

通信機能を階層構造に分割したもの。  
ISOによって制定された。  
通信機能を **7つ** に分けて制定している。  

>>>
### レイヤー構成

<div style="text-align:left;">

##### 1層 物理層　　　　　　　
##### 2層 データリンク層　　　
##### 3層 インターネット層　　
##### 4層 トランスポート層　　
##### 5層 セッション層　　　　
##### 6層 プレゼンテーション層
##### 7層 アプリケーション層　

</div>

>>>
### 1. 物理層
物理的な接続等を取り決める。

例： 電話線・UTP  
※今回物理層は扱いません

>>>
### 2. データリンク層
直接繋がれている端末同士のやり取り等を取り決める。

例： **Ethernet**、IEEE 802.11、PPPoE

>>>
### 3. インターネット層
ネットワーク同士の通信。  
通信経路の選択（ルーティング）

例： **IPv4**、IPv6、ARP

>>>
### 4. トランスポート層
ネットワークの端から端までの通信のやり取りを行う。
再送処理や、エラー訂正等を行い、通信の信頼性を担保する。
（担保しないものもある。）

例： **TCP**、**UDP**

>>>
### 5. セッション層
通信しているプログラム間の通信の開始、  
終了等の手順を決めている。

例： TLS(?)

>>>
### 6. プレゼンテーション層
データの表現方法に関するプロトコル。

例：SMTP、FTP

>>>
### 7. アプリケーション層
具体的なサービス提供に関するプロトコル。

例：**HTTP**、DHCP、SMTP、SNMP、SMB、FTP

>>>

### レイヤーごとに具体的なプロトコルのパケットを見ていきましょう。

<<<

## その前に

>>>

#### ここからパケットを飛ばしながら、解説します。
#### まずパケットの送受信について調べましょう。 

>>>

### raw_socket
生のパケット（バイナリ）を  
送受信できるソケット。

>>>

### raw_socketの準備の仕方

lib/netutils.h InitRawSocket

>>>

### 手順

1. socket関数を使って、ソケットを取得
2. ioctl関数を使って、
3. bind関数を使ってバインド（）する。

>>>

### コード(Initraw_socket)

```c
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <linux/if.h>
#include <net/ethernet.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <netinet/udp.h>
#include <netpacket/packet.h>
#include <netinet/if_ether.h>


/**
 * @brief RAWソケットを準備する
 * @param (device) ネットワークインターフェース名
 * @return socketのディスクリプタ
 */
int InitRawSocket(char *device) {
    // ネットワークデバイスを設定する際に
    // ioctl というシステムコール時に渡して
    // 設定や情報取得を行うための構造体
    struct ifreq ifreq;
    // デバイスに依存しない物理層のアドレスを格納するプロトコル
    struct sockaddr_ll sa;
    // ソケット(データリンク層を扱うディスクリプタ)
    int soc;

    // ソケットを用意
    // 第一引数 : プロトコルファミリ→ PF_PACKET(L2)
    // 第二引数 : 通信方式→ SOCK_RAW
    // 第三引数 : データリンク層→ ETH_P_IP (IPパケットのみ)
    if((soc = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_IP))) < 0) {
        fprintf(stderr, "[init] socket error\n");
        return -1;
    }

    // ifreqをゼロ初期化
    memset(&ifreq, 0, sizeof(struct ifreq));
    // ネットワークデバイス名をifreq.ifr_nameにコピー
    strncpy(ifreq.ifr_name, device, sizeof(ifreq.ifr_name) -1);
    // インターフェース名に対応した
    // インターフェースのインデックスを取得
    // 第一引数 : オープンされたディスクリプタ
    // 第二引数 : デバイスドライバに対する個々の操作に割り当てられた番→ SIOCGIFINDEX
    // インデックスの流し先→ ifreq
    if(ioctl(soc, SIOCGIFINDEX, &ifreq) < 0) {
        fprintf(stderr, "[init] ioctl error\n");
        close(soc);
        return -1;
    }

    // sa.sll_family (デバイスに依存しない物理層の構造体のプロトコルファミリ部)に、
    // PF_PACKET (L2のプロトコルファミリ)を設定
    sa.sll_family = PF_PACKET;
    // sa.sll_protocol (デバイスに依存しない物理層の構造体のプロトコル部)に、
    // ホストバイトオーダからネットワークバイトオーダに変換した、
    // IPパケットのみを取得することを示したデータを格納
    sa.sll_protocol = htons(ETH_P_IP);
    // ifreq.ifr_ifindex に格納されたインターフェース番号をsa.sll_ifindexに設定
    sa.sll_ifindex = ifreq.ifr_ifindex;

    // 第一引数で指定されたディスクリプターで参照されるソケットに、
    // 第二引数で指定されたアドレスを割り当てる。
    // 第一引数 : 元のディスクリプタ
    // 第二引数 : 割り当て先
    // 第三引数 : 第二引数の指す構造体のサイズ
    if(bind(soc, (struct sockaddr *)&sa, sizeof(sa)) < 0) {
        fprintf(stderr, "[init] bind error\n");
        close(soc);
        return -1;
    }

    return soc;
}

```

>>>

### パケットの送信

write関数を使う

```c
/**
 * @param (soc) ソケット
 * @param (ptr) パケットのポインタ
 * @param (size) パケットのサイズ
 */
if(size = write(soc, ptr, size) <= 0){
    // 失敗したらエラーを開く
    perror("write");
    return -1;
}

```

>>>

### パケットの受信

read関数を使う

```c
/**
 * @param (soc) ソケット
 * @param (buf) 読み込むパケットの保存先のポインタ
 * @param (size) bufのサイズ
 */

// パケットの読み込み
if(size = read(soc, buf, sizeof(buf)) <= 0){
    // 失敗したらエラーを開く
    perror("read");
    return -1;
}

```

<<<

# Ethernet

>>>

### Ethernetとは

有線のLANで最も使用されている技術規格。
OSI参照モデルの下位2つの層である物理層とデータリンク層に関して規定している。

>>>

### イーサネットのフレーム（パケット）

| 名前 | サイズ | 詳細 |
|---|---|---|
| ブリアンブル | 8 | フレームの始まりを合図する |
| 宛先MACアドレス | 6 | 宛先のMACアドレス |
| 送信元MACアドレス | 6 | 送信元MACアドレス |


>>>

### 続き

| 名前 | サイズ | 詳細 |
|---|---|---|
| タイプ | 2 | 上位プロトコルの番号 |
| データ | 46〜1500 | データだよ |
| FCS | 4 | チェックサム的ななつ |


>>>

### 構造体
linux/if_ehter.h

```c
 struct ethhdr
 {
    unsigned char   h_dest[ETH_ALEN];   /* destination eth addr */
    unsigned char   h_source[ETH_ALEN]; /* source ether addr    */
    unsigned short  h_proto;        /* packet type ID field */
 };

```

raw_socket側では宛先MACアドレス、  
送信元MACアドレス、タイプしか扱わない

<<<

## Ethernetパケットを
## 受信してみる

>>>

### 手順

#### 1. パケットの受け取り　　　　
#### 2. 解析して構造体に落とし込む
#### 3. パケットの表示　　　　　　

>>>

### コード

server/src/ethernet.c

```c
int Serv(int soc){
    // 変数の宣言
    Packet packet;
    unsigned char buf[2048];

    // パケットの読み込み
    if((packet.size = read(soc, buf, sizeof(buf))) <= 0){
        // 失敗したらエラーを開く
        perror("read");
        return -1;
    }

    packet.ptr = buf;

    // パケットを構造体に当てはめる
    AnalyzePacket(&packet);

    // 表示
    PrintEthernet(&packet);
    PrintRawEthernet(&packet);
        
    return 0;
}

```

>>>

### コード（パケットの解析）

lib/analyze.c

```c
/**
 * @brief イーサネットパケットの解析
 * @param (packet) パケットの構造体
 * @param (lest_packet) パケットのバイナリデータを持つ構造体
 */
int AnalyzeEtherPacket(Packet *packet, RawPacket *lest_packet){
    // 残りポインタ
    unsigned char *ptr = lest_packet -> buf;

    // 残りのサイズ
    int lest = lest_packet -> lest;

    if(lest < sizeof(struct ether_header)) {
        // デバッグしてデバイスナンバートサイズを表示
        return -1;
    }

    // パケットのポインタをイーサネットに
    // 無理やりキャストして代入
    packet -> eh = (struct ether_header *)ptr;

    // ポインタを読んだ分まで加算
    ptr += sizeof(struct ether_header);

    // 残りサイズを読んだ分減算
    lest -= sizeof(struct ether_header);

    // バッファのポインタをコピー
    lest_packet -> buf = ptr;

    // 残りサイズをコピー
    lest_packet -> lest = lest;

    return 0;
}

// 省略

/**
 * @brief パケットの解析
 * @param (packet) パケットの構造体
 * @param (lest_packet) パケットのバイナリデータを持つ構造体
 */
int AnalyzePacket(Packet *packet){
    RawPacket lest_packet = {
        packet -> ptr,
        packet -> size
    };
    
    AnalyzeEtherPacket(packet, &lest_packet);
    
    // 省略

    return 0;
}

```

>>>

### パケット表示

lib/print.c

```c
/**
 * @brief パケットのバイナリを表示
 * @param (packet) パケット
 */
void PrintRawPacket(Packet *packet){
    RawPacket raw_packet = {
        packet -> ptr,
        packet -> size
    };

    printf("-*-*-*-*-  Raw Packet  -*-*-*-*-\n");

    PrintBinary(raw_packet);
}

// 省略

/**
 * @brief イーサネットを表示する
 * @param (packet) パケット
 */
void PrintEthernet(Packet *packet){
    char dhost[19];
    char shost[19];

    snprintf(dhost, sizeof(dhost), "%02x:%02x:%02x:%02x:%02x:%02x",
        packet -> eh -> ether_dhost[0],
        packet -> eh -> ether_dhost[1],
        packet -> eh -> ether_dhost[2],
        packet -> eh -> ether_dhost[3],
        packet -> eh -> ether_dhost[4],
        packet -> eh -> ether_dhost[5]
    );

    snprintf(shost, sizeof(shost), "%02x:%02x:%02x:%02x:%02x:%02x",
        packet -> eh -> ether_shost[0],
        packet -> eh -> ether_shost[1],
        packet -> eh -> ether_shost[2],
        packet -> eh -> ether_shost[3],
        packet -> eh -> ether_shost[4],
        packet -> eh -> ether_shost[5]
    );

    printf("-*-*-*-*- Ethernet -*-*-*-*-\n");
    printf("destionation : %s\n", dhost);
    printf("source       : %s\n", shost);
    printf("type         : %d\n\n", packet -> eh -> ether_type);
}
```

<<<

## Ethernetパケットを
## 送信してみる

>>>

### 手順

#### 1. イーサネットパケットの用意
#### 2. パケットの用意（後に説明）
#### 3. 送信　　　　　　　　　　　
#### 4. パケットの表示　　　　　　

>>>

### コード

client/src/ethernet.c

```c
int Send(int soc){
    // 変数の宣言
    Packet packet;
    int size;
    struct ether_header eh;

    // パケットの初期化
    sprintf(eh.ether_dhost, "\x00\x00\x00\x00\x00\x00");
    sprintf(eh.ether_shost, "\x00\x00\x00\x00\x00\x00");
    eh.ether_type = (u_int16_t)8;

    GenerateEthernetPacket(&packet, &eh);

    PrintEthernet(&packet);
    PrintRawPacket(&packet);

    // パケットの読み込み
    if((size = write(soc, packet.ptr, packet.size)) <= 0){
        // 失敗したらエラーを開く
        perror("write");
        return -1;
    }

    // パケットの開放
    FreePacket(&packet);

    return 0;
}

```

>>>

### コード（ヒープへの移動）
ether_headerをヒープに移動します。  
（理由は後に説明）

lib/generate.c

```c
void GenerateEthernetPacket(Packet *packet, struct ether_header *eh) {
    size_t size = sizeof(struct ether_header);
    packet -> ptr = (unsigned char *)malloc(size);
    packet -> eh = (struct ether_header *)packet -> ptr;
    memcpy(packet -> eh, eh, sizeof(struct ether_header));
    packet -> size = sizeof(struct ether_header);
}

```

>>>

### メモリ開放
ヒープを開放する

lib/generate.c

```c
void FreePacket(Packet *packet) {
    free(packet -> ptr);
}
```


<<<

## 送信したパケットを解析

>>>

### C言語だと

```c
    sprintf(eh.ether_dhost, "\x00\x00\x00\x00\x00\x00");
    sprintf(eh.ether_shost, "\x00\x00\x00\x00\x00\x00");
    eh.ether_type = (u_int16_t)8;
```

>>>

### イーサネットのフレーム（パケット）

| 名前 | 値| 詳細 |
|---|---|---|
| 宛先MACアドレス | 00:00:00:00:00:00 | 宛先のMACアドレス |
| 送信元MACアドレス | 00:00:00:00:00:00 | 送信元MACアドレス |
| タイプ | 8 | 上位プロトコルはIP |


>>>

### wiresharkでみる

![](./img/ethernet.png)

>>>

### wiresharkでみる

![](./img/ethernet1.png)

<<<

### Ethernetパケットを
### 完全に理解したところで（）

>>>

### 次はIPパケットやります。

<<<

# IP

>>>

### IPとは

インターネットにおいてパケットを  
中継するのに使われるプロトコル。
OSI参照モデルの第三層について規定している。

>>>

### IPのパケット

| 名前 | サイズ | 詳細 |
|---|---|---|
| version | 4bit | IPのバージョン |
| ihl | 4bit | IPヘッダの長さ |
| tos | 1 | パケットの優先順位 |
| tot_len | 2 | パケット全体のサイズ |
| id | 2 | パケットのID |

>>>

### IPのパケット

| 名前 | サイズ | 詳細 |
|---|---|---|
| frag_off | 2 | 分割に関するフラグ |
| ttl | 1 | 経由可能デバイス数 |
| protocol | 1 | 上位プロトコル |
| check | 2 | チェックサム |
| saddr | 4 | 送信元IPアドレス |
| daddr | 4 | 送信先IPアドレス |

>>>

### 構造体

netinet/ip.h

```c
struct iphdr
  {
#if __BYTE_ORDER == __LITTLE_ENDIAN
    unsigned int ihl:4;
    unsigned int version:4;
#elif __BYTE_ORDER == __BIG_ENDIAN
    unsigned int version:4;
    unsigned int ihl:4;
#else
# error "Please fix <bits/endian.h>"
#endif
    u_int8_t tos;
    u_int16_t tot_len;
    u_int16_t id;
    u_int16_t frag_off;
    u_int8_t ttl;
    u_int8_t protocol;
    u_int16_t check;
    u_int32_t saddr;
    u_int32_t daddr;
    /*The options start here. */
  };
```

<<<

## IPパケットを
## 受信してみる

>>>

### 手順
Ethernetと違いなし。  

#### 1. パケットの受け取り　　　　
#### 2. 解析して構造体に落とし込む
#### 3. パケットの表示　　　　　　


>>>
### コード

server/src/ip.c

```c
/**
 * @brief 実際のパケットの受取部
 * @param (soc) ソケット
 * @return 成功したら1, 失敗したら-1
 */
int Serv(int soc){
   // 変数の宣言
    Packet packet;
    unsigned char buf[2048];

    // パケットの読み込み
    if((packet.size = read(soc, buf, sizeof(buf))) <= 0){
        // 失敗したらエラーを開く
        perror("read");
        return -1;
    }

    packet.ptr = buf;

    // パケットを構造体に当てはめる
    AnalyzePacket(&packet);

    // 表示
    printf("text:\n");
    PrintEthernet(&packet);
    if (htons(packet.eh -> ether_type) == ETHERTYPE_IP) {
        PrintIP(&packet);
    }

    printf("binary\n");
    PrintRawEthernet(&packet);
    if (htons(packet.eh -> ether_type) == ETHERTYPE_IP) {
        PrintRawIP(&packet);
    }
    PrintRawPacket(&packet);

    return 0;
}
```

>>>

### コード（パケットの解析）

lib/analyze.c

```
/**
 * @brief IPパケットの解析
 * @param (packet) パケットの構造体
 * @param (lest_packet) パケットのバイナリデータを持つ構造体
 */
int AnalyzeIPPacket(Packet *packet, RawPacket *lest_packet){
    // 読み込んだ部分からのポインタ
    unsigned char *ptr = lest_packet -> buf;
    
    // 読み込んでない残りのサイズ
    int lest = lest_packet -> lest;
    
    // ipのパケットの構造体を宣言
    struct iphdr *iphdr;

    // オプション
    unsigned char *option;

    // オプションの長さ、パケッtの長さ
    int optionLen, len;
    
    // チェックサム
    unsigned short sum;

    // 構造体のサイズ分データがあるかのチェック
    if(lest < sizeof(struct iphdr)){
        // sizeが不足した場合にエラーを吐く
        fprintf(stderr, "lest(%d)<sizeof(struct iphdr)\n", lest);
        return -1;
    }

    // ptrをiphdrに無理やりキャストして代入
    iphdr = (struct iphdr *)ptr;
    
    // ptrにパケットのデータ部を代入
    ptr += sizeof(struct iphdr);
    
    // lestにパケットのデータサイズを代入
    lest -= sizeof(struct iphdr);

    // オプションの大きさ(IPヘッダ長を4で割った値 * 4 - ヘッダの大きさ)を格納
    optionLen = iphdr -> ihl * 4 - sizeof(struct iphdr);
    if(optionLen > 0){
        if(optionLen >= 1500){
            // オプションのサイズが大きすぎたらエラーを吐く
            fprintf(stderr, "IP optionLen(%d):too big\n", optionLen);
            return -1;
        }
        // サイズがちょうどよかったら
        // ptrの値をoption に代入
        option = ptr;
        // ptrをoptionLen分読み進める
        ptr += optionLen;
        // lestをoptionLen分減らす
        lest -= optionLen;
    }

    // IPのチェックサムの確認
    if(checkIPchecksum(iphdr, option, optionLen) == 0){
        // チェックサムを見てパケットが壊れたら、エラーを吐く
        fprintf(stderr, "bad ip checksum\n");
        return -1;
    }

    // バッファのポインタをコピー
    lest_packet -> buf = ptr;

    // 残りサイズをコピー
    lest_packet -> lest = lest;
    
    // IPヘッダをコピー
    packet -> ip = iphdr;

    return 0;
}

// 省略

/**
 * @brief パケットの解析
 * @param (packet) パケットの構造体
 * @param (lest_packet) パケットのバイナリデータを持つ構造体
 */
int AnalyzePacket(Packet *packet){
    RawPacket lest_packet = {
        packet -> ptr,
        packet -> size
    };

    AnalyzeEtherPacket(packet, &lest_packet);

    if (htons(packet -> eh -> ether_type) == ETHERTYPE_IP){
        if (AnalyzeIPPacket(packet, &lest_packet) == -1){
            return -1;
        }

        // 省略

    }

    // 省略

    return 0;
}
```

>>>

### パケット表示
lib/print.c

```c

/**
 * @brief バイナリを表示
 * @param (raw_packet) パケット
 */
void PrintBinary(RawPacket raw_packet) {
    int count = 0;
    
    printf("size:%d\n\n", raw_packet.lest);

    // バイナリを表示する
    while (0 < raw_packet.lest) {
        printf("%02x ", *(raw_packet.buf));
        raw_packet.buf += sizeof(unsigned char);
        raw_packet.lest -= sizeof(unsigned char);
        count ++;

        if (count % 5 == 0) {
            // バイナリ5つにうち1回
            // 改行を入れる
            putchar('\n');
        }
    }

    puts("\n");
}

/**
 * @brief パケットのバイナリを表示
 * @param (packet) パケット
 */
void PrintRawPacket(Packet *packet){
    RawPacket raw_packet = {
        packet -> ptr,
        packet -> size
    };

    printf("-*-*-*-*-  Raw Packet  -*-*-*-*-\n");

    PrintBinary(raw_packet);
}

/**
 * @brief パケットのバイナリを表示
 * @param (packet) パケット
 */
void PrintRawEthernet(Packet *packet){
    RawPacket raw_packet = {
        (unsigned char *)packet -> eh,
        sizeof(struct ether_header)
    };

    printf("-*-*-*-*- Raw Ethernet -*-*-*-*-\n");

    PrintBinary(raw_packet);
}

/**
 * @brief IPのバイナリを表示
 * @param (packet) パケット
 */
void PrintRawIP(Packet *packet){
    RawPacket raw_packet = {
        (unsigned char *)packet -> ip,
        sizeof(struct iphdr)
    };

    printf("-*-*-*-*-    Raw IP    -*-*-*-*-\n");

    PrintBinary(raw_packet);
}

/**
 * @brief UDPのバイナリを表示
 * @param (packet) パケット
 */
void PrintRawUDP(Packet *packet){
    RawPacket raw_packet = {
        (unsigned char *)packet -> udp,
        sizeof(struct udphdr)
    };

    printf("-*-*-*-*-   Raw UDP   -*-*-*-*-\n");

    PrintBinary(raw_packet);
}

// 省略

/**
 * @brief データ部のバイナリを表示
 * @param (packet) パケット
 */
void PrintRawData(Packet *packet){
    RawPacket raw_packet = {
        (unsigned char *)packet -> data,
        packet -> data_size
    };

    printf("-*-*-*-*-   Raw DATA   -*-*-*-*-\n");

    PrintBinary(raw_packet);
}

void PrintString(RawPacket raw_packet) {
    char *data = (char *)malloc(raw_packet.lest + sizeof(char));
    memcpy(data, raw_packet.buf, raw_packet.lest);
    data[raw_packet.lest + 1] = 0x0;

    printf("%s", data);

    free(data);
}

/**
 * @brief イーサネットを表示する
 * @param (packet) パケット
 */
void PrintEthernet(Packet *packet){
    char dhost[19];
    char shost[19];

    snprintf(dhost, sizeof(dhost), "%02x:%02x:%02x:%02x:%02x:%02x",
        packet -> eh -> ether_dhost[0],
        packet -> eh -> ether_dhost[1],
        packet -> eh -> ether_dhost[2],
        packet -> eh -> ether_dhost[3],
        packet -> eh -> ether_dhost[4],
        packet -> eh -> ether_dhost[5]
    );

    snprintf(shost, sizeof(shost), "%02x:%02x:%02x:%02x:%02x:%02x",
        packet -> eh -> ether_shost[0],
        packet -> eh -> ether_shost[1],
        packet -> eh -> ether_shost[2],
        packet -> eh -> ether_shost[3],
        packet -> eh -> ether_shost[4],
        packet -> eh -> ether_shost[5]
    );

    printf("-*-*-*-*- Ethernet -*-*-*-*-\n");
    printf("destionation : %s\n", dhost);
    printf("source       : %s\n", shost);
    printf("type         : %d\n\n", packet -> eh -> ether_type);
}

void PrintIP(Packet *packet){
    char saddr[15];
    char daddr[15];

    inet_ntop(AF_INET, &(packet -> ip -> saddr), saddr, sizeof(saddr));
    inet_ntop(AF_INET, &(packet -> ip -> daddr), daddr, sizeof(daddr));

    printf("-*-*-*-*-    IP    -*-*-*-*-\n");
    printf("version          : %d\n", packet -> ip -> version);
    printf("IP header length : %d\n", packet -> ip -> ihl);
    printf("type of service  : %d\n", packet -> ip -> tos);
    printf("total length     : %d\n", packet -> ip -> tot_len);
    printf("identification   : %d\n", packet -> ip -> id);
    printf("frag offset      : %d\n", packet -> ip -> frag_off);
    printf("time to live     : %d\n", packet -> ip -> ttl);
    printf("protocol         : %d\n", packet -> ip -> protocol);
    printf("checksum         : %d\n", packet -> ip -> check);
    printf("destionation     : %s\n", daddr);
    printf("source           : %s\n\n", saddr);
}

void PrintUDP(Packet *packet) {
    printf("-*-*-*-*-   UDP   -*-*-*-*-\n");

    printf("source port      : %d\n", htons(packet -> udp -> uh_sport));
    printf("destination port : %d\n", htons(packet -> udp -> uh_dport));
    printf("udp length       : %d\n", htons(packet -> udp -> uh_ulen));
    printf("checksum         : %x\n\n", htons(packet -> udp -> uh_sum));
}

// 省略

void PrintData(Packet *packet){
    printf("-*-*-*-*-   DATA   -*-*-*-*-\n");
    if (packet -> data_size <= 0) {
        return;
    }

    RawPacket raw_packet = {
        packet -> data,
        packet -> data_size
    };

    PrintString(raw_packet);
    printf("\n\n");
}

```

<<<

## IPパケットを
## 送信してみる

>>>

### 手順
Ethernetと違いなし。

#### 1. パケットの作成　　　　　　
#### 2. 解析して構造体に落とし込む
#### 3. パケットの表示　　　　　　

>>>

### コード

client/src/ip.c

```c
/**
 * @brief 実際のパケットの受取部
 * @param (soc) ソケット
 * @return 成功したら1, 失敗したら-1
 */
int Send(int soc){
    // 変数の宣言
    int size;
    Packet packet;

    struct ether_header eh;

    // シードをセット
    srand(time(NULL));

    // パケットの初期化
    // Ethernet
    sprintf(eh.ether_dhost, "\x00\x00\x00\x00\x00\x00");
    sprintf(eh.ether_shost, "\x00\x00\x00\x00\x00\x00");
    eh.ether_type = (u_int16_t)8;
    
    // IP
    struct iphdr ip = {
        sizeof(struct iphdr) / 4,
        4,
        (u_int8_t)0,
        (u_int16_t)htons(sizeof(struct iphdr)),
        (u_int16_t)htons(rand() % 0x10000),
        (u_int16_t)0,
        (u_int8_t)1,
        (u_int8_t)17,
        (u_int16_t)0x00,
        (u_int32_t)0x00,
        (u_int32_t)0x00        
    };

    inet_pton(AF_INET, "192.168.10.112", &(ip.saddr));
    inet_pton(AF_INET, "192.168.10.112", &(ip.daddr));

    ip.check = checksum2((unsigned char *)&ip, sizeof(struct iphdr), NULL, 0);

    packet.ip = &ip;

    // パケットの実態の生成
    GenerateEthernetPacket(&packet, &eh);
    AddIPHeader(&packet, &ip);

    // パケットの表示
    PrintEthernet(&packet);
    PrintIP(&packet);
    PrintRawEthernet(&packet);    
    PrintRawIP(&packet);
    PrintRawPacket(&packet);

    // パケットの送信
    if((size = write(soc, packet.ptr, packet.size)) <= 0){
        // 失敗したらエラーを開く
        perror("write");
        return -1;
    }

    // パケットの開放
    FreePacket(&packet);

    return 0;
}

```

>>>

### コード（パケットの作成）

lib/generate.c

```c
void GenerateEthernetPacket(Packet *packet, struct ether_header *eh) {
    size_t size = sizeof(struct ether_header);
    packet -> ptr = (unsigned char *)malloc(size);
    packet -> eh = (struct ether_header *)packet -> ptr;
    memcpy(packet -> eh, eh, sizeof(struct ether_header));
    packet -> size = sizeof(struct ether_header);
}

void AddIPHeader(Packet *packet, struct iphdr *ip) {
    size_t size = sizeof(struct iphdr);
    packet -> ptr = (unsigned char *)realloc(packet -> ptr, packet -> size + size);
    packet -> ip = (struct iphdr *)(packet -> ptr + packet -> size);
    memcpy(packet -> ip, ip, sizeof(struct iphdr));
    packet -> size = size + packet -> size;
}
```

>>>

### メモリ開放
Ethernetのときと同じ

lib/generate.c

```c
void FreePacket(Packet *packet) {
    free(packet -> ptr);
}
```

<<<

## 送信したパケットを解析

>>>

### C言語だと

```c
// パケットの初期化
// Ethernet
sprintf(eh.ether_dhost, "\x00\x00\x00\x00\x00\x00");
sprintf(eh.ether_shost, "\x00\x00\x00\x00\x00\x00");
eh.ether_type = (u_int16_t)8;

// IP
struct iphdr ip = {
    sizeof(struct iphdr) / 4,
    4,
    (u_int8_t)0,
    (u_int16_t)htons(sizeof(struct iphdr)),
    (u_int16_t)htons(rand() % 0x10000),
    (u_int16_t)htons(0b01000000000000000000000 + (rand() % 0x100)),
    (u_int8_t)1,
    (u_int8_t)17,
    (u_int16_t)0x00,
    (u_int32_t)0x00,
    (u_int32_t)0x00        
};

inet_pton(AF_INET, "192.168.10.112", &(ip.saddr));
inet_pton(AF_INET, "192.168.10.112", &(ip.daddr));

ip.check = checksum2((unsigned char *)&ip, sizeof(struct iphdr), NULL, 0);

// パケットの実態の生成
GenerateEthernetPacket(&packet, &eh);
AddIPHeader(&packet, &ip);

```

>>>

### Ethernetのフレーム
前回と変わらず

| 名前 | 値| 詳細 |
|---|---|---|
| 宛先MACアドレス | 00:00:00:00:00:00 | 宛先のMACアドレス |
| 送信元MACアドレス | 00:00:00:00:00:00 | 送信元MACアドレス |
| タイプ | 8 | 上位プロトコルはIP |

>>>

### IPのパケット

| 名前 | 値 | 詳細 |
|---|---|---|
| version | 4 | IPv4 |
| ihl | iphdrのサイズ / 4 | optionはなし |
| tos | 0 | パケットの優先順位 |
| tot_len | iphdrのサイズ | データがない、※ |
| id | ランダム | ※ |

※リトルエンディアン

>>>

### IPのパケット

| 名前 | 値 | 詳細 |
|---|---|---|
| frag_off | 0 | 分割に関するフラグ |
| ttl | 1 | 1回のみ経由可能 |
| protocol | 17 | 上位プロトコルはUDP |
| check | チェックサム | チェックサム |
| saddr | 127.0.0.1 | 送信元IPアドレス |
| daddr | 127.0.0.1 | 送信先IPアドレス |

※リトルエンディアン

>>>

### WIRESHARKでみる

![](./img/ip.png)

<<<

# UDP

>>>

### UDPとは

OSI参照モデルの第4層について規定するプロトコル。
TCPと比べると、安全性が保証されていない。


>>>

### UDPのパケット

| 名前 | サイズ | 詳細 |
|---|---|---|
| uh_sport | 2 | 送信元port |
| uh_dport | 2 | 宛先port |
| uh_ulen | 2 | udpパケットのサイズ |
| uh_sum | 2 | チェックサム |


>>>

### 構造体

netinet/udp.h


```c
 struct udphdr {
         u_int16_t uh_sport;           /* source port */
         u_int16_t uh_dport;           /* destination port */
         u_int16_t uh_ulen;            /* udp length */
         u_int16_t uh_sum;             /* udp checksum */
 };
```

<<<

## UDPパケットを
## 受信してみる

>>>

### 手順
Ethernet、IPと違いなし。  

#### 1. パケットの受け取り　　　　
#### 2. 解析して構造体に落とし込む
#### 3. パケットの表示　　　　　　


>>>

### コード

server/src/udp.c

```c
/**
 * @brief 実際のパケットの受取部
 * @param (soc) ソケット
 * @return 成功したら1, 失敗したら-1
 */
int Send(int soc){
    // 変数の宣言
    int size;
    struct ether_header eh;

    Packet packet;

    // シードをセット
    srand(time(NULL));

    // パケットの初期化
    // Data
    unsigned char data[] = "hello world";

    // Ethernet
    sprintf(eh.ether_dhost, "\x00\x00\x00\x00\x00\x00");
    sprintf(eh.ether_shost, "\x00\x00\x00\x00\x00\x00");
    eh.ether_type = (u_int16_t)8;
    
    // IP
    int over_eh_size =  
            + sizeof(struct iphdr) 
            + sizeof(struct udphdr) 
            + sizeof(data);

    struct iphdr ip = {
        sizeof(struct iphdr) / 4,
        4,
        (u_int8_t)0,
        (u_int16_t)htons(over_eh_size),
        (u_int16_t)htons(rand() % 0x10000),
        (u_int16_t)0,
        (u_int8_t)1,
        (u_int8_t)17,
        (u_int16_t)0x00,
        (u_int32_t)0x00,
        (u_int32_t)0x00        
    };

    inet_pton(AF_INET, "192.168.10.112", &(ip.saddr));
    inet_pton(AF_INET, "192.168.10.112", &(ip.daddr));

    ip.check = checksum2((unsigned char *)&ip, sizeof(struct iphdr), NULL, 0);

    // udp
    struct udphdr udp = {
        (u_int16_t)ntohs(rand() % 0x50000),
        (u_int16_t)ntohs(8080),
        (u_int16_t)ntohs(sizeof(udp) + sizeof(data)),
        (u_int16_t)0x00
    };

    // 実体の生成
    GenerateEthernetPacket(&packet, &eh);
    AddIPHeader(&packet, &ip);
    AddUDPHeader(&packet, &udp);
    AddData(&packet, data, sizeof(data));

    // 表示
    printf("text:\n");
    PrintEthernet(&packet);
    PrintIP(&packet);
    PrintUDP(&packet);
    PrintData(&packet);

    printf("binary:\n");
    PrintRawEthernet(&packet);
    PrintRawIP(&packet);
    PrintRawUDP(&packet);
    PrintRawData(&packet);
    PrintRawPacket(&packet);


    // パケットの読み込み
    if((size = write(soc, packet.ptr, packet.size)) <= 0){
        // 失敗したらエラーを開く
        perror("write");
        return -1;
    }

    FreePacket(&packet);

    return 0;
}

```

>>>

### コード（パケットの解析）

lib/analyze.c

```c

/**
 * @brief イーサネットパケットの解析
 * @param (packet) パケットの構造体
 * @param (lest_packet) パケットのバイナリデータを持つ構造体
 */
int AnalyzeEtherPacket(Packet *packet, RawPacket *lest_packet){
    // 残りポインタ
    unsigned char *ptr = lest_packet -> buf;

    // 残りのサイズ
    int lest = lest_packet -> lest;

    if(lest < sizeof(struct ether_header)) {
        // デバッグしてデバイスナンバートサイズを表示
        return -1;
    }

    // パケットのポインタをイーサネットに
    // 無理やりキャストして代入
    packet -> eh = (struct ether_header *)ptr;

    // ポインタを読んだ分まで加算
    ptr += sizeof(struct ether_header);

    // 残りサイズを読んだ分減算
    lest -= sizeof(struct ether_header);

    // バッファのポインタをコピー
    lest_packet -> buf = ptr;

    // 残りサイズをコピー
    lest_packet -> lest = lest;

    return 0;
}



/**
 * @brief IPパケットの解析
 * @param (packet) パケットの構造体
 * @param (lest_packet) パケットのバイナリデータを持つ構造体
 */
int AnalyzeIPPacket(Packet *packet, RawPacket *lest_packet){
    // 読み込んだ部分からのポインタ
    unsigned char *ptr = lest_packet -> buf;
    
    // 読み込んでない残りのサイズ
    int lest = lest_packet -> lest;
    
    // ipのパケットの構造体を宣言
    struct iphdr *iphdr;

    // オプション
    unsigned char *option;

    // オプションの長さ、パケッtの長さ
    int optionLen, len;
    
    // チェックサム
    unsigned short sum;

    // 構造体のサイズ分データがあるかのチェック
    if(lest < sizeof(struct iphdr)){
        // sizeが不足した場合にエラーを吐く
        fprintf(stderr, "lest(%d)<sizeof(struct iphdr)\n", lest);
        return -1;
    }

    // ptrをiphdrに無理やりキャストして代入
    iphdr = (struct iphdr *)ptr;
    
    // ptrにパケットのデータ部を代入
    ptr += sizeof(struct iphdr);
    
    // lestにパケットのデータサイズを代入
    lest -= sizeof(struct iphdr);

    // オプションの大きさ(IPヘッダ長を4で割った値 * 4 - ヘッダの大きさ)を格納
    optionLen = iphdr -> ihl * 4 - sizeof(struct iphdr);
    if(optionLen > 0){
        if(optionLen >= 1500){
            // オプションのサイズが大きすぎたらエラーを吐く
            fprintf(stderr, "IP optionLen(%d):too big\n", optionLen);
            return -1;
        }
        // サイズがちょうどよかったら
        // ptrの値をoption に代入
        option = ptr;
        // ptrをoptionLen分読み進める
        ptr += optionLen;
        // lestをoptionLen分減らす
        lest -= optionLen;
    }

    // IPのチェックサムの確認
    if(checkIPchecksum(iphdr, option, optionLen) == 0){
        // チェックサムを見てパケットが壊れたら、エラーを吐く
        fprintf(stderr, "bad ip checksum\n");
        return -1;
    }

    // バッファのポインタをコピー
    lest_packet -> buf = ptr;

    // 残りサイズをコピー
    lest_packet -> lest = lest;
    
    // IPヘッダをコピー
    packet -> ip = iphdr;

    return 0;
}

/**
 * @brief UDPパケットの解析
 * @param (packet) パケットの構造体
 * @param (lest_packet) パケットのバイナリデータを持つ構造体
 */
int AnalyzeUDPPacket(Packet *packet, RawPacket *lest_packet){
    // 読み込んだ部分からのポインタ
    unsigned char *ptr = lest_packet -> buf;

    // 読み込む残りのサイズ
    int lest = lest_packet -> lest;

    // udpのヘッダの構造体を宣言
    struct udphdr *udphdr;

    // 構造体のサイズ分データがあるかのチェック
    if(lest < sizeof(struct udphdr)){
        // sizeが不足した場合にエラーを吐く
        fprintf(stderr, "lest(%d)<sizeof(struct udphdr)\n", lest);
        return -1;
    }

    // ptrをudphdrに無理やりキャストして代入
    udphdr = (struct udphdr *)ptr;

    // チェックサムをチェック
    // int len = ntohs(packet -> ip -> tot_len) - packet -> ip -> ihl * 4;
    // if(udphdr -> check != 0 && checkIPDATAchecksum(packet -> ip, ptr, len) == 0){
    //     packet -> udp = NULL;
    //     fprintf(stderr, "bad udp checksum\n");
    //     return -1;
    // }
    
    // ptrにパケットのデータ部を代入
    ptr += sizeof(struct udphdr);
    // lestにパケットのデータ部のサイズを代入
    lest -= sizeof(struct udphdr);

    // バッファのポインタをコピー
    lest_packet -> buf = ptr;

    // 残りサイズをコピー
    lest_packet -> lest = lest;

    // UDPヘッダをコピー
    packet -> udp = udphdr;

    return 0;
}

// 省略

/**
 * @brief パケットの解析
 * @param (packet) パケットの構造体
 * @param (lest_packet) パケットのバイナリデータを持つ構造体
 */
int AnalyzePacket(Packet *packet){
    RawPacket lest_packet = {
        packet -> ptr,
        packet -> size
    };
    
    AnalyzeEtherPacket(packet, &lest_packet);
    
    if (htons(packet -> eh -> ether_type) == ETHERTYPE_IP){
        if (AnalyzeIPPacket(packet, &lest_packet) == -1){
            return -1;
        }

        if (packet -> ip -> protocol == IPPROTO_UDP) {
            if(AnalyzeUDPPacket(packet, &lest_packet) == -1) {
                return -1;
            }
        }
        
        // 省略

    }

    packet -> data = lest_packet.buf;
    packet -> data_size = lest_packet.lest;

    return 0;
}
```

>>>

### パケット表示
lib/print.c

```c

/**
 * @brief バイナリを表示
 * @param (raw_packet) パケット
 */
void PrintBinary(RawPacket raw_packet) {
    int count = 0;
    
    printf("size:%d\n\n", raw_packet.lest);

    // バイナリを表示する
    while (0 < raw_packet.lest) {
        printf("%02x ", *(raw_packet.buf));
        raw_packet.buf += sizeof(unsigned char);
        raw_packet.lest -= sizeof(unsigned char);
        count ++;

        if (count % 5 == 0) {
            // バイナリ5つにうち1回
            // 改行を入れる
            putchar('\n');
        }
    }

    puts("\n");
}

/**
 * @brief パケットのバイナリを表示
 * @param (packet) パケット
 */
void PrintRawPacket(Packet *packet){
    RawPacket raw_packet = {
        packet -> ptr,
        packet -> size
    };

    printf("-*-*-*-*-  Raw Packet  -*-*-*-*-\n");

    PrintBinary(raw_packet);
}

/**
 * @brief パケットのバイナリを表示
 * @param (packet) パケット
 */
void PrintRawEthernet(Packet *packet){
    RawPacket raw_packet = {
        (unsigned char *)packet -> eh,
        sizeof(struct ether_header)
    };

    printf("-*-*-*-*- Raw Ethernet -*-*-*-*-\n");

    PrintBinary(raw_packet);
}

/**
 * @brief IPのバイナリを表示
 * @param (packet) パケット
 */
void PrintRawIP(Packet *packet){
    RawPacket raw_packet = {
        (unsigned char *)packet -> ip,
        sizeof(struct iphdr)
    };

    printf("-*-*-*-*-    Raw IP    -*-*-*-*-\n");

    PrintBinary(raw_packet);
}

/**
 * @brief UDPのバイナリを表示
 * @param (packet) パケット
 */
void PrintRawUDP(Packet *packet){
    RawPacket raw_packet = {
        (unsigned char *)packet -> udp,
        sizeof(struct udphdr)
    };

    printf("-*-*-*-*-   Raw UDP   -*-*-*-*-\n");

    PrintBinary(raw_packet);
}

// 省略

/**
 * @brief データ部のバイナリを表示
 * @param (packet) パケット
 */
void PrintRawData(Packet *packet){
    RawPacket raw_packet = {
        (unsigned char *)packet -> data,
        packet -> data_size
    };

    printf("-*-*-*-*-   Raw DATA   -*-*-*-*-\n");

    PrintBinary(raw_packet);
}

void PrintString(RawPacket raw_packet) {
    char *data = (char *)malloc(raw_packet.lest + sizeof(char));
    memcpy(data, raw_packet.buf, raw_packet.lest);
    data[raw_packet.lest + 1] = 0x0;

    printf("%s", data);

    free(data);
}

/**
 * @brief イーサネットを表示する
 * @param (packet) パケット
 */
void PrintEthernet(Packet *packet){
    char dhost[19];
    char shost[19];

    snprintf(dhost, sizeof(dhost), "%02x:%02x:%02x:%02x:%02x:%02x",
        packet -> eh -> ether_dhost[0],
        packet -> eh -> ether_dhost[1],
        packet -> eh -> ether_dhost[2],
        packet -> eh -> ether_dhost[3],
        packet -> eh -> ether_dhost[4],
        packet -> eh -> ether_dhost[5]
    );

    snprintf(shost, sizeof(shost), "%02x:%02x:%02x:%02x:%02x:%02x",
        packet -> eh -> ether_shost[0],
        packet -> eh -> ether_shost[1],
        packet -> eh -> ether_shost[2],
        packet -> eh -> ether_shost[3],
        packet -> eh -> ether_shost[4],
        packet -> eh -> ether_shost[5]
    );

    printf("-*-*-*-*- Ethernet -*-*-*-*-\n");
    printf("destionation : %s\n", dhost);
    printf("source       : %s\n", shost);
    printf("type         : %d\n\n", packet -> eh -> ether_type);
}

void PrintIP(Packet *packet){
    char saddr[15];
    char daddr[15];

    inet_ntop(AF_INET, &(packet -> ip -> saddr), saddr, sizeof(saddr));
    inet_ntop(AF_INET, &(packet -> ip -> daddr), daddr, sizeof(daddr));

    printf("-*-*-*-*-    IP    -*-*-*-*-\n");
    printf("version          : %d\n", packet -> ip -> version);
    printf("IP header length : %d\n", packet -> ip -> ihl);
    printf("type of service  : %d\n", packet -> ip -> tos);
    printf("total length     : %d\n", packet -> ip -> tot_len);
    printf("identification   : %d\n", packet -> ip -> id);
    printf("frag offset      : %d\n", packet -> ip -> frag_off);
    printf("time to live     : %d\n", packet -> ip -> ttl);
    printf("protocol         : %d\n", packet -> ip -> protocol);
    printf("checksum         : %d\n", packet -> ip -> check);
    printf("destionation     : %s\n", daddr);
    printf("source           : %s\n\n", saddr);
}

void PrintUDP(Packet *packet) {
    printf("-*-*-*-*-   UDP   -*-*-*-*-\n");

    printf("source port      : %d\n", htons(packet -> udp -> uh_sport));
    printf("destination port : %d\n", htons(packet -> udp -> uh_dport));
    printf("udp length       : %d\n", htons(packet -> udp -> uh_ulen));
    printf("checksum         : %x\n\n", htons(packet -> udp -> uh_sum));
}

// 省略

void PrintData(Packet *packet){
    printf("-*-*-*-*-   DATA   -*-*-*-*-\n");
    if (packet -> data_size <= 0) {
        return;
    }

    RawPacket raw_packet = {
        packet -> data,
        packet -> data_size
    };

    PrintString(raw_packet);
    printf("\n\n");
}

```




                </section>
            </div>
        </div>

        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>

        <script>
            // More info about config & dependencies:
            // - https://github.com/hakimel/reveal.js#configuration
            // - https://github.com/hakimel/reveal.js#dependencies
            Reveal.initialize({
                history: true,
                dependencies: [
                    { src: 'plugin/markdown/marked.js' },
                    { src: 'plugin/markdown/markdown.js' },
                    { src: 'plugin/notes/notes.js', async: true },
                    { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
                ]
            });
        </script>
    </body>
</html>

