
<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

        <title>reveal.js</title>

        <link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/black.css">

        <!-- Theme used for syntax highlighting of code -->
        <link rel="stylesheet" href="lib/css/zenburn.css">

        <!-- Printing and PDF exports -->
        <script>
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>
    </head>
    <body>
        <style>
        img {
            border-style:none;
        }
        </style>

        <div class="reveal">
            <div class="slides">
                <section 
                    data-markdown
                    data-separator="^\n<<<$"
                    data-separator-vertical="^\n>>>$">

# パケットを作ろう！
#### 作って学ぶパケット入門

<<<

## 自己紹介

>>>

## あかこう
@akakou_py 

セキュリティが好き。

![](https://pbs.twimg.com/profile_images/811407669894385664/8dQkt863_400x400.jpg)

<<<

## 皆さんは

>>>

## wireshark
## 覗いたことありますか？

>>>

### wireshark
* ネットワークプロトコルアナライザ
* これを使うとパケットが見れる

![](https://cdn-ssl-devio-img.classmethod.jp/wp-content/uploads/2014/08/wireshark_icon.jpg)

>>>

### 初めてwiresharkと出会った僕
「へぇ〜これを使うとパケットが見えるんだぁ〜、すごいなぁ〜」

>>>

![](./img/wireshark.png)

>>>

### 確かにパケットが見える
## しかし**読めるとは言ってない**

>>>

パケットを読むには
パケットの知識が必要

>>>

#### そこで僕は様々な手段を試しました

* ### 読書
* ### 自作ルータ
* ### 自作パケット

>>>

* ## 自作ルータ
* ## 自作パケット

>>>

* # 自作パケット

>>>

### 自作パケットすごい良かった

* そのパケット持つ値を理解していかないと次に進まない感が良い
* L3、L4のパケットの内容に関してはほとんど理解できる

>>>

### でもこんなところが悪かった

* #### とても辛かった
* #### ある程度知識がないと進まない 


>>>

## 今回は

### 基礎知識をつけながら
### （楽しく？）

パケットを自作を通して、  
パケットについて解説していきたいと思います。

>>>

## 早速やっていきましょう！
![](https://emojipedia-us.s3.amazonaws.com/thumbs/160/apple/129/thumbs-up-sign_1f44d.png)


<<<

## その前に

>>>

### パケットを作る前に
* ソースコード等は https://github.com/akakou/let-us-make-packet でダウンロードできます。
* 基本的にC言語を用いて説明します。
  * C言語がわからなくとも、理解できるように説明します。
* ミス等あれば @akakou_py まで！

>>>

### パケットを作る前に
* 今回の発表だけで完全に理解するは難しいです。
  * 発表聞いて、後に自作パケットをしやすくなるように話します。
  * なんとなく理解するようにして下さい。

>>>

### パケットを作る前に

* ガチプロの方へ
  * 「自作パケット？百万回ぐらい聞いたわ」と思うかもしれませんが、若造の説明をチェックする気持ちで聞いていただければ嬉しいです。

<<<

## 基礎知識を学ぶ

>>>

### パケットを読むにも、作るにも
### TCP/IPに関する知識が必要です。


>>>
### パケットを詳細に理解する前に、
### TCP/IPについて
### 簡単に復習しましょう。

<<<

## Protocol

>>>

### Protocol（プロトコル）とは

#### 通信をする際のルールや
#### 決まりごと（のようなもの）。  

>>>
### 例を上げるならば
HTTP, FTP, TCP, UDP, IP, IPv6, ARP, Ethernet, IEEE 802.11, PPP

<<<
## OSI参照モデル

>>>
### OSI参照モデルとは

通信機能を階層構造に分割したもの。  
ISOによって制定された。  
通信機能を **7つ** に分けて制定している。  

>>>
### レイヤー構成

<div style="text-align:left;">

##### 1層 物理層　　　　　　　
##### 2層 データリンク層　　　
##### 3層 インターネット層　　
##### 4層 トランスポート層　　
##### 5層 セッション層　　　　
##### 6層 プレゼンテーション層
##### 7層 アプリケーション層　

</div>

>>>
### 1. 物理層
物理的な接続等を取り決める。

例： 電話線・UTP  
※今回物理層は扱いません

>>>
### 2. データリンク層
直接繋がれている端末同士のやり取り等を取り決める。

例： **Ethernet**、IEEE 802.11、PPPoE

>>>
### 3. インターネット層
複数のネットワークを介した通信。  
通信経路の選択（ルーティング）

例： **IPv4**、IPv6、ARP

>>>
### 4. トランスポート層
ネットワークの端から端までの通信のやり取りを行う。
再送処理や、エラー訂正等を行い、通信の信頼性を担保する。
（担保しないものもある。）

例： **TCP**、**UDP**

>>>
### 5. セッション層
通信しているプログラム間の通信の開始、  
終了等の手順を決めている。

例： TLS(?)

>>>
### 6. プレゼンテーション層
データの表現方法に関するプロトコル。

例：SMTP、FTP

>>>
### 7. アプリケーション層
具体的なサービス提供に関するプロトコル。

例：**HTTP**、DHCP、SMTP、SNMP、SMB、FTP

>>>

### レイヤーごとに具体的なプロトコルのパケットを見ていきましょう。

<<<

## その前に

>>>

#### ここからパケットを飛ばしながら、解説します。
#### まずパケットの送受信について調べましょう。 

>>>

### raw_socket
生のパケット（バイナリ）を  
送受信できるソケット。

>>>

### raw_socketの準備の仕方

lib/netutils.h

>>>

### 手順

1. socket関数を使って、ソケットを取得
2. ioctl関数を使って、インタフェース名からインタフェース番号を取得
3. bind関数を使ってインタフェース番号をbindします。

>>>

### コード(ソケットの用意）

```c
/**
 * @brief RAWソケットを準備する
 * @param (device) ネットワークインターフェース名
 * @return socketのディスクリプタ
 */
int InitRawSocket(char *device) {
    // ネットワークデバイスを設定する際に
    // ioctl というシステムコール時に渡して
    // 設定や情報取得を行うための構造体
    struct ifreq ifreq;
    // デバイスに依存しない物理層のアドレスを格納するプロトコル
    struct sockaddr_ll sa;
    // ソケット(データリンク層を扱うディスクリプタ)
    int soc;

    // ソケットを用意
    // 第一引数 : プロトコルファミリ→ PF_PACKET(L2)
    // 第二引数 : 通信方式→ SOCK_RAW
    // 第三引数 : データリンク層→ ETH_P_IP (IPパケットのみ)
    if((soc = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_IP))) < 0) {
        fprintf(stderr, "[init] socket error\n");
        return -1;
    }

    // ifreqをゼロ初期化
    memset(&ifreq, 0, sizeof(struct ifreq));
    // ネットワークデバイス名をifreq.ifr_nameにコピー
    strncpy(ifreq.ifr_name, device, sizeof(ifreq.ifr_name) -1);
    // インターフェース名に対応した
    // インターフェースのインデックスを取得
    // 第一引数 : オープンされたディスクリプタ
    // 第二引数 : デバイスドライバに対する個々の操作に割り当てられた番→ SIOCGIFINDEX
    // インデックスの流し先→ ifreq
    if(ioctl(soc, SIOCGIFINDEX, &ifreq) < 0) {
        fprintf(stderr, "[init] ioctl error\n");
        close(soc);
        return -1;
    }

    // sa.sll_family (デバイスに依存しない物理層の構造体のプロトコルファミリ部)に、
    // PF_PACKET (L2のプロトコルファミリ)を設定
    sa.sll_family = PF_PACKET;
    // sa.sll_protocol (デバイスに依存しない物理層の構造体のプロトコル部)に、
    // ホストバイトオーダからネットワークバイトオーダに変換した、
    // IPパケットのみを取得することを示したデータを格納
    sa.sll_protocol = htons(ETH_P_IP);
    // ifreq.ifr_ifindex に格納されたインターフェース番号をsa.sll_ifindexに設定
    sa.sll_ifindex = ifreq.ifr_ifindex;

    // 第一引数で指定されたディスクリプターで参照されるソケットに、
    // 第二引数で指定されたアドレスを割り当てる。
    // 第一引数 : 元のディスクリプタ
    // 第二引数 : 割り当て先
    // 第三引数 : 第二引数の指す構造体のサイズ
    if(bind(soc, (struct sockaddr *)&sa, sizeof(sa)) < 0) {
        fprintf(stderr, "[init] bind error\n");
        close(soc);
        return -1;
    }

    return soc;
}

```

>>>

### パケットの送信

write関数を使う

```c
/**
 * @param (soc) ソケット
 * @param (ptr) パケットのポインタ
 * @param (size) パケットのサイズ
 */
if(size = write(soc, ptr, size) <= 0){
    // 失敗したらエラーを開く
    perror("write");
    return -1;
}

```

>>>

### パケットの受信

read関数を使う

```c
/**
 * @param (soc) ソケット
 * @param (buf) 読み込むパケットの保存先のポインタ
 * @param (size) bufのサイズ
 */

// パケットの読み込み
if(size = read(soc, buf, sizeof(buf)) <= 0){
    // 失敗したらエラーを開く
    perror("read");
    return -1;
}

```

<<<

# Ethernet

>>>

### Ethernetとは

有線のLANで最も使用されている技術規格。
OSI参照モデルの下位2つの層である物理層とデータリンク層に関して規定している。

>>>

### イーサネットのフレーム（パケット）

| 名前 | サイズ | 詳細 |
|---|---|---|
| ブリアンブル | 8 | フレームの始まりを合図する |
| 宛先MACアドレス | 6 | 宛先のMACアドレス |
| 送信元MACアドレス | 6 | 送信元MACアドレス |


>>>

### 続き

| 名前 | サイズ | 詳細 |
|---|---|---|
| タイプ | 2 | 上位プロトコルの番号 |
| データ | 46〜1500 | データだよ |
| FCS | 4 | チェックサム的ななつ |


>>>

### 構造体
linux/if_ehter.h

```c
 struct ethhdr
 {
    unsigned char   h_dest[ETH_ALEN];   /* destination eth addr */
    unsigned char   h_source[ETH_ALEN]; /* source ether addr    */
    unsigned short  h_proto;        /* packet type ID field */
 };

```

raw_socket側では宛先MACアドレス、  
送信元MACアドレス、タイプしか扱わない

<<<

## Ethernetパケットを
## 受信してみる

>>>

### 手順

#### 1. パケットの受け取り　　　　
#### 2. 解析して構造体に落とし込む
#### 3. パケットの表示　　　　　　

>>>

### コード

server/src/ethernet.c

```c
int Serv(int soc){
    // 変数の宣言
    Packet packet;
    unsigned char buf[2048];

    // パケットの読み込み
    if((packet.size = read(soc, buf, sizeof(buf))) <= 0){
        // 失敗したらエラーを開く
        perror("read");
        return -1;
    }

    packet.ptr = buf;

    // パケットを構造体に当てはめる
    AnalyzePacket(&packet);

    // 表示
    PrintEthernet(&packet);
    PrintRawEthernet(&packet);
        
    return 0;
}

```

>>>

### コード（パケットの解析）

lib/analyze.c

```c
/**
 * @brief イーサネットパケットの解析
 * @param (packet) パケットの構造体
 * @param (lest_packet) パケットのバイナリデータを持つ構造体
 */
int AnalyzeEtherPacket(Packet *packet, RawPacket *lest_packet){
    // 残りポインタ
    unsigned char *ptr = lest_packet -> buf;

    // 残りのサイズ
    int lest = lest_packet -> lest;

    if(lest < sizeof(struct ether_header)) {
        // デバッグしてデバイスナンバートサイズを表示
        return -1;
    }

    // パケットのポインタをイーサネットに
    // 無理やりキャストして代入
    packet -> eh = (struct ether_header *)ptr;

    // ポインタを読んだ分まで加算
    ptr += sizeof(struct ether_header);

    // 残りサイズを読んだ分減算
    lest -= sizeof(struct ether_header);

    // バッファのポインタをコピー
    lest_packet -> buf = ptr;

    // 残りサイズをコピー
    lest_packet -> lest = lest;

    return 0;
}

// 省略

/**
 * @brief パケットの解析
 * @param (packet) パケットの構造体
 * @param (lest_packet) パケットのバイナリデータを持つ構造体
 */
int AnalyzePacket(Packet *packet){
    RawPacket lest_packet = {
        packet -> ptr,
        packet -> size
    };
    
    AnalyzeEtherPacket(packet, &lest_packet);
    
    // 省略

    return 0;
}

```

>>>

### パケット表示

lib/print.c

```c

/**
 * @brief バイナリを表示
 * @param (raw_packet) パケット
 */
void PrintBinary(RawPacket raw_packet) {
    int count = 0;
    
    printf("size:%d\n\n", raw_packet.lest);

    // バイナリを表示する
    while (0 < raw_packet.lest) {
        printf("%02x ", *(raw_packet.buf));
        raw_packet.buf += sizeof(unsigned char);
        raw_packet.lest -= sizeof(unsigned char);
        count ++;

        if (count % 5 == 0) {
            // バイナリ5つにうち1回
            // 改行を入れる
            putchar('\n');
        }
    }

    puts("\n");
}

/**
 * @brief パケットのバイナリを表示
 * @param (packet) パケット
 */
void PrintRawPacket(Packet *packet){
    RawPacket raw_packet = {
        packet -> ptr,
        packet -> size
    };

    printf("-*-*-*-*-  Raw Packet  -*-*-*-*-\n");

    PrintBinary(raw_packet);
}

// 省略

/**
 * @brief イーサネットを表示する
 * @param (packet) パケット
 */
void PrintEthernet(Packet *packet){
    char dhost[19];
    char shost[19];

    snprintf(dhost, sizeof(dhost), "%02x:%02x:%02x:%02x:%02x:%02x",
        packet -> eh -> ether_dhost[0],
        packet -> eh -> ether_dhost[1],
        packet -> eh -> ether_dhost[2],
        packet -> eh -> ether_dhost[3],
        packet -> eh -> ether_dhost[4],
        packet -> eh -> ether_dhost[5]
    );

    snprintf(shost, sizeof(shost), "%02x:%02x:%02x:%02x:%02x:%02x",
        packet -> eh -> ether_shost[0],
        packet -> eh -> ether_shost[1],
        packet -> eh -> ether_shost[2],
        packet -> eh -> ether_shost[3],
        packet -> eh -> ether_shost[4],
        packet -> eh -> ether_shost[5]
    );

    printf("-*-*-*-*- Ethernet -*-*-*-*-\n");
    printf("destionation : %s\n", dhost);
    printf("source       : %s\n", shost);
    printf("type         : %d\n\n", packet -> eh -> ether_type);
}
```

<<<

## Ethernetパケットを
## 送信してみる

>>>

### 手順

#### 1. イーサネットパケットの用意
#### 2. パケットの用意（後に説明）
#### 3. 送信　　　　　　　　　　　
#### 4. パケットの表示　　　　　　

>>>

### コード

client/src/ethernet.c

```c
int Send(int soc){
    // 変数の宣言
    Packet packet;
    int size;
    struct ether_header eh;

    // パケットの初期化
    sprintf(eh.ether_dhost, "\x00\x00\x00\x00\x00\x00");
    sprintf(eh.ether_shost, "\x00\x00\x00\x00\x00\x00");
    eh.ether_type = (u_int16_t)8;

    GenerateEthernetPacket(&packet, &eh);

    PrintEthernet(&packet);
    PrintRawPacket(&packet);

    // パケットの読み込み
    if((size = write(soc, packet.ptr, packet.size)) <= 0){
        // 失敗したらエラーを開く
        perror("write");
        return -1;
    }

    // パケットの開放
    FreePacket(&packet);

    return 0;
}

```

>>>

### コード（ヒープへの移動）
ether_headerをヒープに移動します。  
（理由は後に説明）

lib/generate.c

```c
void GenerateEthernetPacket(Packet *packet, struct ether_header *eh) {
    size_t size = sizeof(struct ether_header);
    packet -> ptr = (unsigned char *)malloc(size);
    packet -> eh = (struct ether_header *)packet -> ptr;
    memcpy(packet -> eh, eh, sizeof(struct ether_header));
    packet -> size = sizeof(struct ether_header);
}

```

>>>

### メモリ開放
ヒープを開放する

lib/generate.c

```c
void FreePacket(Packet *packet) {
    free(packet -> ptr);
}
```


<<<

## 送信したEthenet
## パケットを解析

>>>

### C言語だと

```c
    sprintf(eh.ether_dhost, "\x00\x00\x00\x00\x00\x00");
    sprintf(eh.ether_shost, "\x00\x00\x00\x00\x00\x00");
    eh.ether_type = (u_int16_t)8;
```

>>>

### イーサネットのフレーム（パケット）

| 名前 | 値| 詳細 |
|---|---|---|
| 宛先MACアドレス | 00:00:00:00:00:00 | 宛先のMACアドレス |
| 送信元MACアドレス | 00:00:00:00:00:00 | 送信元MACアドレス |
| タイプ | 8 | 上位プロトコルはIP |


>>>

### wiresharkでみる

![](./img/ethernet.png)

<<<

### Ethernetパケットを
### 完全に理解したところで（）

>>>

### 次はIPパケットやります。

<<<

# IP

>>>

### IPとは

インターネットにおいてパケットを  
中継するのに使われるプロトコル。
OSI参照モデルの第三層について規定している。

>>>

### IPのパケット

| 名前 | サイズ | 詳細 |
|---|---|---|
| version | 4bit | IPのバージョン |
| ihl | 4bit | IPヘッダの長さ |
| tos | 1 | パケットの優先順位 |
| tot_len | 2 | パケット全体のサイズ |
| id | 2 | パケットのID |

>>>

### IPのパケット

| 名前 | サイズ | 詳細 |
|---|---|---|
| frag_off | 2 | 分割に関するフラグ |
| ttl | 1 | 経由可能デバイス数 |
| protocol | 1 | 上位プロトコル |
| check | 2 | チェックサム |
| saddr | 4 | 送信元IPアドレス |
| daddr | 4 | 送信先IPアドレス |

>>>

### 構造体

netinet/ip.h

```c
struct iphdr
  {
#if __BYTE_ORDER == __LITTLE_ENDIAN
    unsigned int ihl:4;
    unsigned int version:4;
#elif __BYTE_ORDER == __BIG_ENDIAN
    unsigned int version:4;
    unsigned int ihl:4;
#else
# error "Please fix <bits/endian.h>"
#endif
    u_int8_t tos;
    u_int16_t tot_len;
    u_int16_t id;
    u_int16_t frag_off;
    u_int8_t ttl;
    u_int8_t protocol;
    u_int16_t check;
    u_int32_t saddr;
    u_int32_t daddr;
    /*The options start here. */
  };
```

<<<

## IPパケットを
## 受信してみる

>>>

### 手順
Ethernetと違いなし。  

#### 1. パケットの受け取り　　　　
#### 2. 解析して構造体に落とし込む
#### 3. パケットの表示　　　　　　


>>>

### コード

server/src/ip.c

```c
/**
 * @brief 実際のパケットの受取部
 * @param (soc) ソケット
 * @return 成功したら1, 失敗したら-1
 */
int Serv(int soc){
   // 変数の宣言
    Packet packet;
    unsigned char buf[2048];

    // パケットの読み込み
    if((packet.size = read(soc, buf, sizeof(buf))) <= 0){
        // 失敗したらエラーを開く
        perror("read");
        return -1;
    }

    packet.ptr = buf;

    // パケットを構造体に当てはめる
    AnalyzePacket(&packet);

    // 表示
    printf("text:\n");
    PrintEthernet(&packet);
    if (htons(packet.eh -> ether_type) == ETHERTYPE_IP) {
        PrintIP(&packet);
    }

    printf("binary\n");
    PrintRawEthernet(&packet);
    if (htons(packet.eh -> ether_type) == ETHERTYPE_IP) {
        PrintRawIP(&packet);
    }
    PrintRawPacket(&packet);

    return 0;
}
```

>>>

### コード（パケットの解析）

lib/analyze.c

```
/**
 * @brief IPパケットの解析
 * @param (packet) パケットの構造体
 * @param (lest_packet) パケットのバイナリデータを持つ構造体
 */
int AnalyzeIPPacket(Packet *packet, RawPacket *lest_packet){
    // 読み込んだ部分からのポインタ
    unsigned char *ptr = lest_packet -> buf;
    
    // 読み込んでない残りのサイズ
    int lest = lest_packet -> lest;
    
    // ipのパケットの構造体を宣言
    struct iphdr *iphdr;

    // オプション
    unsigned char *option;

    // オプションの長さ、パケッtの長さ
    int optionLen, len;
    
    // チェックサム
    unsigned short sum;

    // 構造体のサイズ分データがあるかのチェック
    if(lest < sizeof(struct iphdr)){
        // sizeが不足した場合にエラーを吐く
        fprintf(stderr, "lest(%d)<sizeof(struct iphdr)\n", lest);
        return -1;
    }

    // ptrをiphdrに無理やりキャストして代入
    iphdr = (struct iphdr *)ptr;
    
    // ptrにパケットのデータ部を代入
    ptr += sizeof(struct iphdr);
    
    // lestにパケットのデータサイズを代入
    lest -= sizeof(struct iphdr);

    // オプションの大きさ(IPヘッダ長を4で割った値 * 4 - ヘッダの大きさ)を格納
    optionLen = iphdr -> ihl * 4 - sizeof(struct iphdr);
    if(optionLen > 0){
        if(optionLen >= 1500){
            // オプションのサイズが大きすぎたらエラーを吐く
            fprintf(stderr, "IP optionLen(%d):too big\n", optionLen);
            return -1;
        }
        // サイズがちょうどよかったら
        // ptrの値をoption に代入
        option = ptr;
        // ptrをoptionLen分読み進める
        ptr += optionLen;
        // lestをoptionLen分減らす
        lest -= optionLen;
    }

    // IPのチェックサムの確認
    if(checkIPchecksum(iphdr, option, optionLen) == 0){
        // チェックサムを見てパケットが壊れたら、エラーを吐く
        fprintf(stderr, "bad ip checksum\n");
        return -1;
    }

    // バッファのポインタをコピー
    lest_packet -> buf = ptr;

    // 残りサイズをコピー
    lest_packet -> lest = lest;
    
    // IPヘッダをコピー
    packet -> ip = iphdr;

    return 0;
}

// 省略

/**
 * @brief パケットの解析
 * @param (packet) パケットの構造体
 * @param (lest_packet) パケットのバイナリデータを持つ構造体
 */
int AnalyzePacket(Packet *packet){
    RawPacket lest_packet = {
        packet -> ptr,
        packet -> size
    };

    AnalyzeEtherPacket(packet, &lest_packet);

    if (htons(packet -> eh -> ether_type) == ETHERTYPE_IP){
        if (AnalyzeIPPacket(packet, &lest_packet) == -1){
            return -1;
        }

        // 省略

    }

    // 省略

    return 0;
}
```

>>>

### パケット表示
lib/print.c

```c

/**
 * @brief バイナリを表示
 * @param (raw_packet) パケット
 */
void PrintBinary(RawPacket raw_packet) {
    int count = 0;
    
    printf("size:%d\n\n", raw_packet.lest);

    // バイナリを表示する
    while (0 < raw_packet.lest) {
        printf("%02x ", *(raw_packet.buf));
        raw_packet.buf += sizeof(unsigned char);
        raw_packet.lest -= sizeof(unsigned char);
        count ++;

        if (count % 5 == 0) {
            // バイナリ5つにうち1回
            // 改行を入れる
            putchar('\n');
        }
    }

    puts("\n");
}

/**
 * @brief パケットのバイナリを表示
 * @param (packet) パケット
 */
void PrintRawPacket(Packet *packet){
    RawPacket raw_packet = {
        packet -> ptr,
        packet -> size
    };

    printf("-*-*-*-*-  Raw Packet  -*-*-*-*-\n");

    PrintBinary(raw_packet);
}

/**
 * @brief パケットのバイナリを表示
 * @param (packet) パケット
 */
void PrintRawEthernet(Packet *packet){
    RawPacket raw_packet = {
        (unsigned char *)packet -> eh,
        sizeof(struct ether_header)
    };

    printf("-*-*-*-*- Raw Ethernet -*-*-*-*-\n");

    PrintBinary(raw_packet);
}

/**
 * @brief IPのバイナリを表示
 * @param (packet) パケット
 */
void PrintRawIP(Packet *packet){
    RawPacket raw_packet = {
        (unsigned char *)packet -> ip,
        sizeof(struct iphdr)
    };

    printf("-*-*-*-*-    Raw IP    -*-*-*-*-\n");

    PrintBinary(raw_packet);
}

/**
 * @brief データ部のバイナリを表示
 * @param (packet) パケット
 */
void PrintRawData(Packet *packet){
    RawPacket raw_packet = {
        (unsigned char *)packet -> data,
        packet -> data_size
    };

    printf("-*-*-*-*-   Raw DATA   -*-*-*-*-\n");

    PrintBinary(raw_packet);
}

void PrintString(RawPacket raw_packet) {
    char *data = (char *)malloc(raw_packet.lest + sizeof(char));
    memcpy(data, raw_packet.buf, raw_packet.lest);
    data[raw_packet.lest + 1] = 0x0;

    printf("%s", data);

    free(data);
}

/**
 * @brief イーサネットを表示する
 * @param (packet) パケット
 */
void PrintEthernet(Packet *packet){
    char dhost[19];
    char shost[19];

    snprintf(dhost, sizeof(dhost), "%02x:%02x:%02x:%02x:%02x:%02x",
        packet -> eh -> ether_dhost[0],
        packet -> eh -> ether_dhost[1],
        packet -> eh -> ether_dhost[2],
        packet -> eh -> ether_dhost[3],
        packet -> eh -> ether_dhost[4],
        packet -> eh -> ether_dhost[5]
    );

    snprintf(shost, sizeof(shost), "%02x:%02x:%02x:%02x:%02x:%02x",
        packet -> eh -> ether_shost[0],
        packet -> eh -> ether_shost[1],
        packet -> eh -> ether_shost[2],
        packet -> eh -> ether_shost[3],
        packet -> eh -> ether_shost[4],
        packet -> eh -> ether_shost[5]
    );

    printf("-*-*-*-*- Ethernet -*-*-*-*-\n");
    printf("destionation : %s\n", dhost);
    printf("source       : %s\n", shost);
    printf("type         : %d\n\n", packet -> eh -> ether_type);
}

void PrintIP(Packet *packet){
    char saddr[15];
    char daddr[15];

    inet_ntop(AF_INET, &(packet -> ip -> saddr), saddr, sizeof(saddr));
    inet_ntop(AF_INET, &(packet -> ip -> daddr), daddr, sizeof(daddr));

    printf("-*-*-*-*-    IP    -*-*-*-*-\n");
    printf("version          : %d\n", packet -> ip -> version);
    printf("IP header length : %d\n", packet -> ip -> ihl);
    printf("type of service  : %d\n", packet -> ip -> tos);
    printf("total length     : %d\n", packet -> ip -> tot_len);
    printf("identification   : %d\n", packet -> ip -> id);
    printf("frag offset      : %d\n", packet -> ip -> frag_off);
    printf("time to live     : %d\n", packet -> ip -> ttl);
    printf("protocol         : %d\n", packet -> ip -> protocol);
    printf("checksum         : %d\n", packet -> ip -> check);
    printf("destionation     : %s\n", daddr);
    printf("source           : %s\n\n", saddr);
}

// 省略

void PrintData(Packet *packet){
    printf("-*-*-*-*-   DATA   -*-*-*-*-\n");
    if (packet -> data_size <= 0) {
        return;
    }

    RawPacket raw_packet = {
        packet -> data,
        packet -> data_size
    };

    PrintString(raw_packet);
    printf("\n\n");
}

```

<<<

## IPパケットを
## 送信してみる

>>>

### 手順
Ethernetと違いなし。

#### 1. パケットの作成　　　　　　
#### 2. 解析して構造体に落とし込む
#### 3. パケットの表示　　　　　　

>>>

### コード

client/src/ip.c

```c
/**
 * @brief 実際のパケットの受取部
 * @param (soc) ソケット
 * @return 成功したら1, 失敗したら-1
 */
int Send(int soc){
    // 変数の宣言
    int size;
    Packet packet;

    struct ether_header eh;

    // シードをセット
    srand(time(NULL));

    // パケットの初期化
    // Ethernet
    sprintf(eh.ether_dhost, "\x00\x00\x00\x00\x00\x00");
    sprintf(eh.ether_shost, "\x00\x00\x00\x00\x00\x00");
    eh.ether_type = (u_int16_t)8;
    
    // IP
    struct iphdr ip = {
        sizeof(struct iphdr) / 4,
        4,
        (u_int8_t)0,
        (u_int16_t)htons(sizeof(struct iphdr)),
        (u_int16_t)htons(rand() % 0x10000),
        (u_int16_t)0,
        (u_int8_t)1,
        (u_int8_t)17,
        (u_int16_t)0x00,
        (u_int32_t)0x00,
        (u_int32_t)0x00        
    };

    inet_pton(AF_INET, "127.0.0.1", &(ip.saddr));
    inet_pton(AF_INET, "127.0.0.1", &(ip.daddr));

    ip.check = checksum2((unsigned char *)&ip, sizeof(struct iphdr), NULL, 0);

    // パケットの実態の生成
    GenerateEthernetPacket(&packet, &eh);
    AddIPHeader(&packet, &ip);

    // パケットの表示
    PrintEthernet(&packet);
    PrintIP(&packet);
    PrintRawEthernet(&packet);    
    PrintRawIP(&packet);
    PrintRawPacket(&packet);

    // パケットの送信
    if((size = write(soc, packet.ptr, packet.size)) <= 0){
        // 失敗したらエラーを開く
        perror("write");
        return -1;
    }

    // パケットの開放
    FreePacket(&packet);

    return 0;
}

```

>>>

### コード（パケットの作成）

lib/generate.c

```c
void GenerateEthernetPacket(Packet *packet, struct ether_header *eh) {
    size_t size = sizeof(struct ether_header);
    packet -> ptr = (unsigned char *)malloc(size);
    packet -> eh = (struct ether_header *)packet -> ptr;
    memcpy(packet -> eh, eh, sizeof(struct ether_header));
    packet -> size = sizeof(struct ether_header);
}

void AddIPHeader(Packet *packet, struct iphdr *ip) {
    size_t size = sizeof(struct iphdr);
    packet -> ptr = (unsigned char *)realloc(packet -> ptr, packet -> size + size);
    packet -> ip = (struct iphdr *)(packet -> ptr + packet -> size);
    memcpy(packet -> ip, ip, sizeof(struct iphdr));
    packet -> size = size + packet -> size;
}
```

>>>

### メモリ開放
Ethernetのときと同じ

lib/generate.c

```c
void FreePacket(Packet *packet) {
    free(packet -> ptr);
}
```

<<<

## 送信したIPパケットを解析

>>>

### C言語だと

```c
// パケットの初期化
// Ethernet
sprintf(eh.ether_dhost, "\x00\x00\x00\x00\x00\x00");
sprintf(eh.ether_shost, "\x00\x00\x00\x00\x00\x00");
eh.ether_type = (u_int16_t)8;

// IP
struct iphdr ip = {
    sizeof(struct iphdr) / 4,
    4,
    (u_int8_t)0,
    (u_int16_t)htons(sizeof(struct iphdr)),
    (u_int16_t)htons(rand() % 0x10000),
    (u_int16_t)htons(0b01000000000000000000000 + (rand() % 0x100)),
    (u_int8_t)1,
    (u_int8_t)17,
    (u_int16_t)0x00,
    (u_int32_t)0x00,
    (u_int32_t)0x00        
};

inet_pton(AF_INET, "127.0.0.1", &(ip.saddr));
inet_pton(AF_INET, "127.0.0.1", &(ip.daddr));

ip.check = checksum2((unsigned char *)&ip, sizeof(struct iphdr), NULL, 0);

// パケットの実態の生成
GenerateEthernetPacket(&packet, &eh);
AddIPHeader(&packet, &ip);

```

>>>

### Ethernetのフレーム
前回と変わらず

| 名前 | 値| 詳細 |
|---|---|---|
| 宛先MACアドレス | 00:00:00:00:00:00 | 宛先のMACアドレス |
| 送信元MACアドレス | 00:00:00:00:00:00 | 送信元MACアドレス |
| タイプ | 8 | 上位プロトコルはIP |

>>>

### IPのパケット

| 名前 | 値 | 詳細 |
|---|---|---|
| version | 4 | IPv4 |
| ihl | iphdrのサイズ / 4 | optionはなし |
| tos | 0 | パケットの優先順位 |
| tot_len | iphdrのサイズ | データがない、※ |
| id | ランダム | ※ |

※リトルエンディアン

>>>

### IPのパケット

| 名前 | 値 | 詳細 |
|---|---|---|
| frag_off | 0 | 分割に関するフラグ |
| ttl | 1 | 1回のみ経由可能 |
| protocol | 17 | 上位プロトコルはUDP |
| check | チェックサム | チェックサム |
| saddr | 127.0.0.1 | 送信元IPアドレス |
| daddr | 127.0.0.1 | 送信先IPアドレス |

※リトルエンディアン

>>>

### WIRESHARKでみる

![](./img/ip.png)

<<<

# UDP

>>>

### UDPとは

OSI参照モデルの第4層について規定するプロトコル。
TCPと比べると、安全性が保証されていない。


>>>

### UDPのパケット

| 名前 | サイズ | 詳細 |
|---|---|---|
| uh_sport | 2 | 送信元port |
| uh_dport | 2 | 宛先port |
| uh_ulen | 2 | udpパケットのサイズ |
| uh_sum | 2 | チェックサム |


>>>

### 構造体

netinet/udp.h


```c
 struct udphdr {
         u_int16_t uh_sport;           /* source port */
         u_int16_t uh_dport;           /* destination port */
         u_int16_t uh_ulen;            /* udp length */
         u_int16_t uh_sum;             /* udp checksum */
 };
```

<<<

## UDPパケットを
## 受信してみる

>>>

### 手順
Ethernet、IPと違いなし。  

#### 1. パケットの受け取り　　　　
#### 2. 解析して構造体に落とし込む
#### 3. パケットの表示　　　　　　


>>>

### コード

server/src/udp.c

```c
/**
 * @brief 実際のパケットの受取部
 * @param (soc) ソケット
 * @return 成功したら1, 失敗したら-1
 */
int Send(int soc){
   // 変数の宣言
    Packet packet;
    unsigned char buf[2048];

    // パケットの読み込み
    if((packet.size = read(soc, buf, sizeof(buf))) <= 0){
        // 失敗したらエラーを開く
        perror("read");
        return -1;
    }

    packet.ptr = buf;

    // パケットを構造体に当てはめる
    AnalyzePacket(&packet);

    // 表示
    printf("text:\n");
    PrintEthernet(&packet);
    if (htons(packet.eh -> ether_type) == ETHERTYPE_IP) {
        PrintIP(&packet);

        if (packet.ip -> protocol == IPPROTO_UDP && packet.udp != NULL) {
            PrintUDP(&packet);
        }
    }
    PrintData(&packet);

    printf("binary\n");
    PrintRawEthernet(&packet);
    if (htons(packet.eh -> ether_type) == ETHERTYPE_IP) {
        PrintRawIP(&packet);

        if (packet.ip -> protocol == IPPROTO_UDP && packet.udp != NULL) {
            PrintRawUDP(&packet);
        }
        PrintRawData(&packet);
    }
    PrintRawPacket(&packet);

    return 0;
}

```

>>>

### コード（パケットの解析）

lib/analyze.c

```c

/**
 * @brief イーサネットパケットの解析
 * @param (packet) パケットの構造体
 * @param (lest_packet) パケットのバイナリデータを持つ構造体
 */
int AnalyzeEtherPacket(Packet *packet, RawPacket *lest_packet){
    // 残りポインタ
    unsigned char *ptr = lest_packet -> buf;

    // 残りのサイズ
    int lest = lest_packet -> lest;

    if(lest < sizeof(struct ether_header)) {
        // デバッグしてデバイスナンバートサイズを表示
        return -1;
    }

    // パケットのポインタをイーサネットに
    // 無理やりキャストして代入
    packet -> eh = (struct ether_header *)ptr;

    // ポインタを読んだ分まで加算
    ptr += sizeof(struct ether_header);

    // 残りサイズを読んだ分減算
    lest -= sizeof(struct ether_header);

    // バッファのポインタをコピー
    lest_packet -> buf = ptr;

    // 残りサイズをコピー
    lest_packet -> lest = lest;

    return 0;
}



/**
 * @brief IPパケットの解析
 * @param (packet) パケットの構造体
 * @param (lest_packet) パケットのバイナリデータを持つ構造体
 */
int AnalyzeIPPacket(Packet *packet, RawPacket *lest_packet){
    // 読み込んだ部分からのポインタ
    unsigned char *ptr = lest_packet -> buf;
    
    // 読み込んでない残りのサイズ
    int lest = lest_packet -> lest;
    
    // ipのパケットの構造体を宣言
    struct iphdr *iphdr;

    // オプション
    unsigned char *option;

    // オプションの長さ、パケッtの長さ
    int optionLen, len;
    
    // チェックサム
    unsigned short sum;

    // 構造体のサイズ分データがあるかのチェック
    if(lest < sizeof(struct iphdr)){
        // sizeが不足した場合にエラーを吐く
        fprintf(stderr, "lest(%d)<sizeof(struct iphdr)\n", lest);
        return -1;
    }

    // ptrをiphdrに無理やりキャストして代入
    iphdr = (struct iphdr *)ptr;
    
    // ptrにパケットのデータ部を代入
    ptr += sizeof(struct iphdr);
    
    // lestにパケットのデータサイズを代入
    lest -= sizeof(struct iphdr);

    // オプションの大きさ(IPヘッダ長を4で割った値 * 4 - ヘッダの大きさ)を格納
    optionLen = iphdr -> ihl * 4 - sizeof(struct iphdr);
    if(optionLen > 0){
        if(optionLen >= 1500){
            // オプションのサイズが大きすぎたらエラーを吐く
            fprintf(stderr, "IP optionLen(%d):too big\n", optionLen);
            return -1;
        }
        // サイズがちょうどよかったら
        // ptrの値をoption に代入
        option = ptr;
        // ptrをoptionLen分読み進める
        ptr += optionLen;
        // lestをoptionLen分減らす
        lest -= optionLen;
    }

    // IPのチェックサムの確認
    if(checkIPchecksum(iphdr, option, optionLen) == 0){
        // チェックサムを見てパケットが壊れたら、エラーを吐く
        fprintf(stderr, "bad ip checksum\n");
        return -1;
    }

    // バッファのポインタをコピー
    lest_packet -> buf = ptr;

    // 残りサイズをコピー
    lest_packet -> lest = lest;
    
    // IPヘッダをコピー
    packet -> ip = iphdr;

    return 0;
}

/**
 * @brief UDPパケットの解析
 * @param (packet) パケットの構造体
 * @param (lest_packet) パケットのバイナリデータを持つ構造体
 */
int AnalyzeUDPPacket(Packet *packet, RawPacket *lest_packet){
    // 読み込んだ部分からのポインタ
    unsigned char *ptr = lest_packet -> buf;

    // 読み込む残りのサイズ
    int lest = lest_packet -> lest;

    // udpのヘッダの構造体を宣言
    struct udphdr *udphdr;

    // 構造体のサイズ分データがあるかのチェック
    if(lest < sizeof(struct udphdr)){
        // sizeが不足した場合にエラーを吐く
        fprintf(stderr, "lest(%d)<sizeof(struct udphdr)\n", lest);
        return -1;
    }

    // ptrをudphdrに無理やりキャストして代入
    udphdr = (struct udphdr *)ptr;

    // チェックサムをチェック
    // int len = ntohs(packet -> ip -> tot_len) - packet -> ip -> ihl * 4;
    // if(udphdr -> check != 0 && checkIPDATAchecksum(packet -> ip, ptr, len) == 0){
    //     packet -> udp = NULL;
    //     fprintf(stderr, "bad udp checksum\n");
    //     return -1;
    // }
    
    // ptrにパケットのデータ部を代入
    ptr += sizeof(struct udphdr);
    // lestにパケットのデータ部のサイズを代入
    lest -= sizeof(struct udphdr);

    // バッファのポインタをコピー
    lest_packet -> buf = ptr;

    // 残りサイズをコピー
    lest_packet -> lest = lest;

    // UDPヘッダをコピー
    packet -> udp = udphdr;

    return 0;
}

// 省略

/**
 * @brief パケットの解析
 * @param (packet) パケットの構造体
 * @param (lest_packet) パケットのバイナリデータを持つ構造体
 */
int AnalyzePacket(Packet *packet){
    RawPacket lest_packet = {
        packet -> ptr,
        packet -> size
    };
    
    AnalyzeEtherPacket(packet, &lest_packet);
    
    if (htons(packet -> eh -> ether_type) == ETHERTYPE_IP){
        if (AnalyzeIPPacket(packet, &lest_packet) == -1){
            return -1;
        }

        if (packet -> ip -> protocol == IPPROTO_UDP) {
            if(AnalyzeUDPPacket(packet, &lest_packet) == -1) {
                return -1;
            }
        }
        
        // 省略

    }

    packet -> data = lest_packet.buf;
    packet -> data_size = lest_packet.lest;

    return 0;
}
```

>>>

### パケット表示
lib/print.c

```c

/**
 * @brief バイナリを表示
 * @param (raw_packet) パケット
 */
void PrintBinary(RawPacket raw_packet) {
    int count = 0;
    
    printf("size:%d\n\n", raw_packet.lest);

    // バイナリを表示する
    while (0 < raw_packet.lest) {
        printf("%02x ", *(raw_packet.buf));
        raw_packet.buf += sizeof(unsigned char);
        raw_packet.lest -= sizeof(unsigned char);
        count ++;

        if (count % 5 == 0) {
            // バイナリ5つにうち1回
            // 改行を入れる
            putchar('\n');
        }
    }

    puts("\n");
}

/**
 * @brief パケットのバイナリを表示
 * @param (packet) パケット
 */
void PrintRawPacket(Packet *packet){
    RawPacket raw_packet = {
        packet -> ptr,
        packet -> size
    };

    printf("-*-*-*-*-  Raw Packet  -*-*-*-*-\n");

    PrintBinary(raw_packet);
}

/**
 * @brief パケットのバイナリを表示
 * @param (packet) パケット
 */
void PrintRawEthernet(Packet *packet){
    RawPacket raw_packet = {
        (unsigned char *)packet -> eh,
        sizeof(struct ether_header)
    };

    printf("-*-*-*-*- Raw Ethernet -*-*-*-*-\n");

    PrintBinary(raw_packet);
}

/**
 * @brief IPのバイナリを表示
 * @param (packet) パケット
 */
void PrintRawIP(Packet *packet){
    RawPacket raw_packet = {
        (unsigned char *)packet -> ip,
        sizeof(struct iphdr)
    };

    printf("-*-*-*-*-    Raw IP    -*-*-*-*-\n");

    PrintBinary(raw_packet);
}

/**
 * @brief UDPのバイナリを表示
 * @param (packet) パケット
 */
void PrintRawUDP(Packet *packet){
    RawPacket raw_packet = {
        (unsigned char *)packet -> udp,
        sizeof(struct udphdr)
    };

    printf("-*-*-*-*-   Raw UDP   -*-*-*-*-\n");

    PrintBinary(raw_packet);
}

// 省略

/**
 * @brief データ部のバイナリを表示
 * @param (packet) パケット
 */
void PrintRawData(Packet *packet){
    RawPacket raw_packet = {
        (unsigned char *)packet -> data,
        packet -> data_size
    };

    printf("-*-*-*-*-   Raw DATA   -*-*-*-*-\n");

    PrintBinary(raw_packet);
}

void PrintString(RawPacket raw_packet) {
    char *data = (char *)malloc(raw_packet.lest + sizeof(char));
    memcpy(data, raw_packet.buf, raw_packet.lest);
    data[raw_packet.lest + 1] = 0x0;

    printf("%s", data);

    free(data);
}

/**
 * @brief イーサネットを表示する
 * @param (packet) パケット
 */
void PrintEthernet(Packet *packet){
    char dhost[19];
    char shost[19];

    snprintf(dhost, sizeof(dhost), "%02x:%02x:%02x:%02x:%02x:%02x",
        packet -> eh -> ether_dhost[0],
        packet -> eh -> ether_dhost[1],
        packet -> eh -> ether_dhost[2],
        packet -> eh -> ether_dhost[3],
        packet -> eh -> ether_dhost[4],
        packet -> eh -> ether_dhost[5]
    );

    snprintf(shost, sizeof(shost), "%02x:%02x:%02x:%02x:%02x:%02x",
        packet -> eh -> ether_shost[0],
        packet -> eh -> ether_shost[1],
        packet -> eh -> ether_shost[2],
        packet -> eh -> ether_shost[3],
        packet -> eh -> ether_shost[4],
        packet -> eh -> ether_shost[5]
    );

    printf("-*-*-*-*- Ethernet -*-*-*-*-\n");
    printf("destionation : %s\n", dhost);
    printf("source       : %s\n", shost);
    printf("type         : %d\n\n", packet -> eh -> ether_type);
}

void PrintIP(Packet *packet){
    char saddr[15];
    char daddr[15];

    inet_ntop(AF_INET, &(packet -> ip -> saddr), saddr, sizeof(saddr));
    inet_ntop(AF_INET, &(packet -> ip -> daddr), daddr, sizeof(daddr));

    printf("-*-*-*-*-    IP    -*-*-*-*-\n");
    printf("version          : %d\n", packet -> ip -> version);
    printf("IP header length : %d\n", packet -> ip -> ihl);
    printf("type of service  : %d\n", packet -> ip -> tos);
    printf("total length     : %d\n", packet -> ip -> tot_len);
    printf("identification   : %d\n", packet -> ip -> id);
    printf("frag offset      : %d\n", packet -> ip -> frag_off);
    printf("time to live     : %d\n", packet -> ip -> ttl);
    printf("protocol         : %d\n", packet -> ip -> protocol);
    printf("checksum         : %d\n", packet -> ip -> check);
    printf("destionation     : %s\n", daddr);
    printf("source           : %s\n\n", saddr);
}

void PrintUDP(Packet *packet) {
    printf("-*-*-*-*-   UDP   -*-*-*-*-\n");

    printf("source port      : %d\n", htons(packet -> udp -> uh_sport));
    printf("destination port : %d\n", htons(packet -> udp -> uh_dport));
    printf("udp length       : %d\n", htons(packet -> udp -> uh_ulen));
    printf("checksum         : %x\n\n", htons(packet -> udp -> uh_sum));
}

// 省略

void PrintData(Packet *packet){
    printf("-*-*-*-*-   DATA   -*-*-*-*-\n");
    if (packet -> data_size <= 0) {
        return;
    }

    RawPacket raw_packet = {
        packet -> data,
        packet -> data_size
    };

    PrintString(raw_packet);
    printf("\n\n");
}

```

<<<

## UDPパケットを
## 送信してみる

>>>

### 手順
Ethernet、IPと違いなし。

#### 1. パケットの作成　　　　　　
#### 2. 解析して構造体に落とし込む
#### 3. パケットの表示　　　　　　

>>>

### コード

client/src/udp.c

```c
/**
 * @brief 実際のパケットの受取部
 * @param (soc) ソケット
 * @return 成功したら1, 失敗したら-1
 */
int Send(int soc){
    // 変数の宣言
    int size;
    struct ether_header eh;

    Packet packet;

    // シードをセット
    srand(time(NULL));

    // パケットの初期化
    // Data
    unsigned char data[] = "hello world";

    // Ethernet
    sprintf(eh.ether_dhost, "\x00\x00\x00\x00\x00\x00");
    sprintf(eh.ether_shost, "\x00\x00\x00\x00\x00\x00");
    eh.ether_type = (u_int16_t)8;
    
    // IP
    int over_eh_size =  
            + sizeof(struct iphdr) 
            + sizeof(struct udphdr) 
            + sizeof(data);

    struct iphdr ip = {
        sizeof(struct iphdr) / 4,
        4,
        (u_int8_t)0,
        (u_int16_t)htons(over_eh_size),
        (u_int16_t)htons(rand() % 0x10000),
        (u_int16_t)0,
        (u_int8_t)1,
        (u_int8_t)17,
        (u_int16_t)0x00,
        (u_int32_t)0x00,
        (u_int32_t)0x00        
    };

    inet_pton(AF_INET, "127.0.0.1", &(ip.saddr));
    inet_pton(AF_INET, "127.0.0.1", &(ip.daddr));

    ip.check = checksum2((unsigned char *)&ip, sizeof(struct iphdr), NULL, 0);

    // udp
    struct udphdr udp = {
        (u_int16_t)ntohs(rand() % 0x50000),
        (u_int16_t)ntohs(8080),
        (u_int16_t)ntohs(sizeof(udp) + sizeof(data)),
        (u_int16_t)0x00
    };

    // 実体の生成
    GenerateEthernetPacket(&packet, &eh);
    AddIPHeader(&packet, &ip);
    AddUDPHeader(&packet, &udp);
    AddData(&packet, data, sizeof(data));

    // 表示
    printf("text:\n");
    PrintEthernet(&packet);
    PrintIP(&packet);
    PrintUDP(&packet);
    PrintData(&packet);

    printf("binary:\n");
    PrintRawEthernet(&packet);
    PrintRawIP(&packet);
    PrintRawUDP(&packet);
    PrintRawData(&packet);
    PrintRawPacket(&packet);


    // パケットの読み込み
    if((size = write(soc, packet.ptr, packet.size)) <= 0){
        // 失敗したらエラーを開く
        perror("write");
        return -1;
    }

    FreePacket(&packet);

    return 0;
}
```

>>>

### コード（パケットの作成）

lib/generate.c

```c
void GenerateEthernetPacket(Packet *packet, struct ether_header *eh) {
    size_t size = sizeof(struct ether_header);
    packet -> ptr = (unsigned char *)malloc(size);
    packet -> eh = (struct ether_header *)packet -> ptr;
    memcpy(packet -> eh, eh, sizeof(struct ether_header));
    packet -> size = sizeof(struct ether_header);
}

void AddIPHeader(Packet *packet, struct iphdr *ip) {
    size_t size = sizeof(struct iphdr);
    packet -> ptr = (unsigned char *)realloc(packet -> ptr, packet -> size + size);
    packet -> ip = (struct iphdr *)(packet -> ptr + packet -> size);
    memcpy(packet -> ip, ip, sizeof(struct iphdr));
    packet -> size = size + packet -> size;
}

void AddUDPHeader(Packet *packet, struct udphdr *udp) {
    size_t size = sizeof(struct udphdr);
    packet -> ptr = (unsigned char *)realloc(packet -> ptr, packet -> size + size);
    packet -> udp = (struct udphdr *)(packet -> ptr + packet -> size);
    memcpy(packet -> udp, udp, sizeof(struct udphdr));
    packet -> size = size + packet -> size;
}
```

>>>

### メモリ開放
Ethernet、IPのときと同じ

lib/generate.c

```c
void FreePacket(Packet *packet) {
    free(packet -> ptr);
}
```





<<<

## 送信したUDPパケットを解析

>>>

### C言語だと

```c
// シードをセット
srand(time(NULL));

// パケットの初期化
// Data
unsigned char data[] = "hello world";

// Ethernet
sprintf(eh.ether_dhost, "\x00\x00\x00\x00\x00\x00");
sprintf(eh.ether_shost, "\x00\x00\x00\x00\x00\x00");
eh.ether_type = (u_int16_t)8;

// IP
int over_eh_size =  
        + sizeof(struct iphdr) 
        + sizeof(struct udphdr) 
        + sizeof(data);

struct iphdr ip = {
    sizeof(struct iphdr) / 4,
    4,
    (u_int8_t)0,
    (u_int16_t)htons(over_eh_size),
    (u_int16_t)htons(rand() % 0x10000),
    (u_int16_t)0,
    (u_int8_t)1,
    (u_int8_t)17,
    (u_int16_t)0x00,
    (u_int32_t)0x00,
    (u_int32_t)0x00        
};

inet_pton(AF_INET, "127.0.0.1", &(ip.saddr));
inet_pton(AF_INET, "127.0.0.1", &(ip.daddr));

ip.check = checksum2((unsigned char *)&ip, sizeof(struct iphdr), NULL, 0);

// udp
struct udphdr udp = {
    (u_int16_t)ntohs(rand() % 0x50000),
    (u_int16_t)ntohs(8080),
    (u_int16_t)ntohs(sizeof(udp) + sizeof(data)),
    (u_int16_t)0x00
};
```

>>>

### Ethernetのフレーム
前回と変わらず

| 名前 | 値| 詳細 |
|---|---|---|
| 宛先MACアドレス | 00:00:00:00:00:00 | 宛先のMACアドレス |
| 送信元MACアドレス | 00:00:00:00:00:00 | 送信元MACアドレス |
| タイプ | 8 | 上位プロトコルはIP |

>>>

### IPのパケット

| 名前 | 値 | 詳細 |
|---|---|---|
| version | 4 | IPv4 |
| ihl | iphdrのサイズ / 4 | optionはなし |
| tos | 0 | パケットの優先順位 |
| tot_len | sizeof(ip+udp+data) | 各サイズの和、※ |
| id | ランダム | ※ |

※リトルエンディアン

>>>

### IPのパケット

| 名前 | 値 | 詳細 |
|---|---|---|
| frag_off | 0 | 分割に関するフラグ |
| ttl | 1 | 1回のみ経由可能 |
| protocol | 17 | 上位プロトコルはUDP |
| check | チェックサム | チェックサム |
| saddr | 127.0.0.1 | 送信元IPアドレス |
| daddr | 127.0.0.1 | 送信先IPアドレス |

>>>


### UDPのパケット

| 名前 | 値 | 詳細 |
|---|---|---|
| uh_sport | ランダム | 送信元port |
| uh_dport | 8080 | 宛先port |
| uh_ulen | udpヘッダとデータのサイズの和 | udpパケットのサイズ |
| uh_sum | 0 | チェックサムはチェックしない |


※uh_sum以外リトルエンディアン

>>>

### データ
> hello world

>>>

### WIRESHARKでみる

![](./img/udp.png)

<<<

# TCP

>>>

### TCPとは

OSI参照モデルの第4層について規定するプロトコル。 UDPと比べると、安全性が保証されている。
（複雑なので今回は、単発でパケットを送受信する）

>>>

### TCPのパケット

| 名前 | サイズ | 詳細 |
|---|---|---|
| th_sport | 2 | 送信元port |
| th_dport | 2 | 宛先port |
| th_seq | 4 | シーケンス番号 |
| th_ack | 4 | 確認応答番号 |
| th_off | 1 | データ + TCPヘッダサイズ |

>>>

### TCPのパケット

| 名前 | サイズ | 詳細 |
|---|---|---|
| th_x2 | 3bit | 未使用 |
| th_flags | 9bit | フラグ |
| th_win | 2 | ウィンドウサイズ |
| th_sum | 2 | チェックサム |
| th_urp | 2 | 緊急情報のポインタ |

>>>

### 構造体

netinet/tcp.h

```c
struct tcphdr
      {
	uint16_t th_sport;	/* source port */
	uint16_t th_dport;	/* destination port */
	tcp_seq th_seq;		/* sequence number */
	tcp_seq th_ack;		/* acknowledgement number */
# if __BYTE_ORDER == __LITTLE_ENDIAN
	uint8_t th_x2:4;	/* (unused) */
	uint8_t th_off:4;	/* data offset */
# endif
# if __BYTE_ORDER == __BIG_ENDIAN
	uint8_t th_off:4;	/* data offset */
	uint8_t th_x2:4;	/* (unused) */
# endif
	uint8_t th_flags;
# define TH_FIN	0x01
# define TH_SYN	0x02
# define TH_RST	0x04
# define TH_PUSH	0x08
# define TH_ACK	0x10
# define TH_URG	0x20
	uint16_t th_win;	/* window */
	uint16_t th_sum;	/* checksum */
	uint16_t th_urp;	/* urgent pointer */
      };

```

<<<

## TCPパケットを
## 受信してみる

>>>

### 手順
Ethernet、IP、UDPと違いなし。  

#### 1. パケットの受け取り　　　　
#### 2. 解析して構造体に落とし込む
#### 3. パケットの表示　　　　　　


>>>

### コード

server/src/tcp.c

```c
/**
 * @brief 実際のパケットの受取部
 * @param (soc) ソケット
 * @return 成功したら1, 失敗したら-1
 */
int Send(int soc){
   // 変数の宣言
    Packet packet;
    unsigned char buf[2048];

    // パケットの読み込み
    if((packet.size = read(soc, buf, sizeof(buf))) <= 0){
        // 失敗したらエラーを開く
        perror("read");
        return -1;
    }

    packet.ptr = buf;

    // パケットを構造体に当てはめる
    AnalyzePacket(&packet);

    // 表示
    printf("text:\n");
    PrintEthernet(&packet);
    if (htons(packet.eh -> ether_type) == ETHERTYPE_IP) {
        PrintIP(&packet);

        if (packet.ip -> protocol == IPPROTO_UDP && packet.udp != NULL) {
            PrintUDP(&packet);
        }
        else if (packet.ip -> protocol == IPPROTO_TCP && packet.tcp != NULL) {
            PrintTCP(&packet);
        }
    }
    PrintData(&packet);

    printf("binary\n");
    PrintRawEthernet(&packet);
    if (htons(packet.eh -> ether_type) == ETHERTYPE_IP) {
        PrintRawIP(&packet);

        if (packet.ip -> protocol == IPPROTO_UDP && packet.udp != NULL) {
            PrintRawUDP(&packet);
        }
        else if (packet.ip -> protocol == IPPROTO_TCP && packet.tcp != NULL){
            PrintRawTCP(&packet);
        }
        PrintRawData(&packet);
    }
    PrintRawPacket(&packet);

    return 0;
}
```

>>>

### コード（パケットの解析）

lib/analyze.c

```

/**
 * @brief イーサネットパケットの解析
 * @param (packet) パケットの構造体
 * @param (lest_packet) パケットのバイナリデータを持つ構造体
 */
int AnalyzeEtherPacket(Packet *packet, RawPacket *lest_packet){
    // 残りポインタ
    unsigned char *ptr = lest_packet -> buf;

    // 残りのサイズ
    int lest = lest_packet -> lest;

    if(lest < sizeof(struct ether_header)) {
        // デバッグしてデバイスナンバートサイズを表示
        return -1;
    }

    // パケットのポインタをイーサネットに
    // 無理やりキャストして代入
    packet -> eh = (struct ether_header *)ptr;

    // ポインタを読んだ分まで加算
    ptr += sizeof(struct ether_header);

    // 残りサイズを読んだ分減算
    lest -= sizeof(struct ether_header);

    // バッファのポインタをコピー
    lest_packet -> buf = ptr;

    // 残りサイズをコピー
    lest_packet -> lest = lest;

    return 0;
}

/**
 * @brief IPパケットの解析
 * @param (packet) パケットの構造体
 * @param (lest_packet) パケットのバイナリデータを持つ構造体
 */
int AnalyzeIPPacket(Packet *packet, RawPacket *lest_packet){
    // 読み込んだ部分からのポインタ
    unsigned char *ptr = lest_packet -> buf;
    
    // 読み込んでない残りのサイズ
    int lest = lest_packet -> lest;
    
    // ipのパケットの構造体を宣言
    struct iphdr *iphdr;

    // オプション
    unsigned char *option;

    // オプションの長さ、パケッtの長さ
    int optionLen, len;
    
    // チェックサム
    unsigned short sum;

    // 構造体のサイズ分データがあるかのチェック
    if(lest < sizeof(struct iphdr)){
        // sizeが不足した場合にエラーを吐く
        fprintf(stderr, "lest(%d)<sizeof(struct iphdr)\n", lest);
        return -1;
    }

    // ptrをiphdrに無理やりキャストして代入
    iphdr = (struct iphdr *)ptr;
    
    // ptrにパケットのデータ部を代入
    ptr += sizeof(struct iphdr);
    
    // lestにパケットのデータサイズを代入
    lest -= sizeof(struct iphdr);

    // オプションの大きさ(IPヘッダ長を4で割った値 * 4 - ヘッダの大きさ)を格納
    optionLen = iphdr -> ihl * 4 - sizeof(struct iphdr);
    if(optionLen > 0){
        if(optionLen >= 1500){
            // オプションのサイズが大きすぎたらエラーを吐く
            fprintf(stderr, "IP optionLen(%d):too big\n", optionLen);
            return -1;
        }
        // サイズがちょうどよかったら
        // ptrの値をoption に代入
        option = ptr;
        // ptrをoptionLen分読み進める
        ptr += optionLen;
        // lestをoptionLen分減らす
        lest -= optionLen;
    }

    // IPのチェックサムの確認
    if(checkIPchecksum(iphdr, option, optionLen) == 0){
        // チェックサムを見てパケットが壊れたら、エラーを吐く
        fprintf(stderr, "bad ip checksum\n");
        return -1;
    }

    // バッファのポインタをコピー
    lest_packet -> buf = ptr;

    // 残りサイズをコピー
    lest_packet -> lest = lest;
    
    // IPヘッダをコピー
    packet -> ip = iphdr;

    return 0;
}

// 省略

/**
 * @brief TCPパケットの解析
 * @param (packet) パケットの構造体
 * @param (lest_packet) パケットのバイナリデータを持つ構造体
 */
int AnalyzeTCPPacket(Packet *packet, RawPacket *lest_packet){
    // 読み込んだ部分からのポインタ
    unsigned char *ptr = lest_packet -> buf;

    // 読み込んでない残りのサイズ
    int lest = lest_packet -> lest;
    
    // tcpのパケットの構造体を宣言
    struct tcphdr *tcphdr;

    // オプション
    unsigned char *option;

    // オプションの長さ、パケッtの長さ
    int optionLen, len;

    // 構造体のサイズ分データがあるかのチェック
    if(lest < sizeof(struct tcphdr)){
        // sizeが不足した場合にエラーを吐く
        fprintf(stderr, "lest(%d) < sizeof(struct tcphdr)\n", lest);
        return -1;
    }

    // ptrをtcphdrに無理やりキャストして代入
    tcphdr = (struct tcphdr *)ptr;
    // ptrにパケットのデータ部を代入
    ptr += sizeof(struct tcphdr);
    // lestにパケットのデータ部のサイズを代入
    lest -= sizeof(struct tcphdr);


    // オプションの大きさ(TCPヘッダ長を5で引いた値 * 4バイトを格納
    optionLen = (tcphdr -> doff - 5) * 4;
    if(optionLen > 0){
        if(optionLen >= 1500){
            // オプションのサイズが大きすぎたらエラーを吐く
            fprintf(stderr, "IP optionLen(%d):too big\n", optionLen);
            return -1;
        }
        // サイズがちょうどよかったら
        // ptrの値をoption に代入
        option = ptr;
        // ptrをoptionLen分読み進める
        ptr += optionLen;
        // lestをoptionLen分減らす
        lest -= optionLen;
    }


    // バッファのポインタをコピー
    lest_packet -> buf = ptr;

    // 残りサイズをコピー
    lest_packet -> lest = lest;

    // TCPヘッダをコピー
    packet -> tcp = tcphdr;

    return(0);
}

/**
 * @brief パケットの解析
 * @param (packet) パケットの構造体
 * @param (lest_packet) パケットのバイナリデータを持つ構造体
 */
int AnalyzePacket(Packet *packet){
    RawPacket lest_packet = {
        packet -> ptr,
        packet -> size
    };
    
    AnalyzeEtherPacket(packet, &lest_packet);
    
    if (htons(packet -> eh -> ether_type) == ETHERTYPE_IP){
        if (AnalyzeIPPacket(packet, &lest_packet) == -1){
            return -1;
        }

        if (packet -> ip -> protocol == IPPROTO_UDP) {
            if(AnalyzeUDPPacket(packet, &lest_packet) == -1) {
                return -1;
            }
        }
        
        else if (packet -> ip -> protocol == IPPROTO_TCP) {
            if(AnalyzeTCPPacket(packet, &lest_packet) == -1) {
                return -1;
            }
        }
    }

    packet -> data = lest_packet.buf;
    packet -> data_size = lest_packet.lest;

    return 0;
}
```

>>>

### パケット表示

lib/print.c

```c
/**
 * @brief バイナリを表示
 * @param (raw_packet) パケット
 */
void PrintBinary(RawPacket raw_packet) {
    int count = 0;
    
    printf("size:%d\n\n", raw_packet.lest);

    // バイナリを表示する
    while (0 < raw_packet.lest) {
        printf("%02x ", *(raw_packet.buf));
        raw_packet.buf += sizeof(unsigned char);
        raw_packet.lest -= sizeof(unsigned char);
        count ++;

        if (count % 5 == 0) {
            // バイナリ5つにうち1回
            // 改行を入れる
            putchar('\n');
        }
    }

    puts("\n");
}

/**
 * @brief パケットのバイナリを表示
 * @param (packet) パケット
 */
void PrintRawPacket(Packet *packet){
    RawPacket raw_packet = {
        packet -> ptr,
        packet -> size
    };

    printf("-*-*-*-*-  Raw Packet  -*-*-*-*-\n");

    PrintBinary(raw_packet);
}

/**
 * @brief パケットのバイナリを表示
 * @param (packet) パケット
 */
void PrintRawEthernet(Packet *packet){
    RawPacket raw_packet = {
        (unsigned char *)packet -> eh,
        sizeof(struct ether_header)
    };

    printf("-*-*-*-*- Raw Ethernet -*-*-*-*-\n");

    PrintBinary(raw_packet);
}

/**
 * @brief IPのバイナリを表示
 * @param (packet) パケット
 */
void PrintRawIP(Packet *packet){
    RawPacket raw_packet = {
        (unsigned char *)packet -> ip,
        sizeof(struct iphdr)
    };

    printf("-*-*-*-*-    Raw IP    -*-*-*-*-\n");

    PrintBinary(raw_packet);
}

/**
 * @brief TCPのバイナリを表示
 * @param (packet) パケット
 */
void PrintRawTCP(Packet *packet){
    RawPacket raw_packet = {
        (unsigned char *)packet -> tcp,
        sizeof(struct tcphdr)
    };

    printf("-*-*-*-*-   Raw TCP   -*-*-*-*-\n");

    PrintBinary(raw_packet);
}

/**
 * @brief データ部のバイナリを表示
 * @param (packet) パケット
 */
void PrintRawData(Packet *packet){
    RawPacket raw_packet = {
        (unsigned char *)packet -> data,
        packet -> data_size
    };

    printf("-*-*-*-*-   Raw DATA   -*-*-*-*-\n");

    PrintBinary(raw_packet);
}

void PrintString(RawPacket raw_packet) {
    char *data = (char *)malloc(raw_packet.lest + sizeof(char));
    memcpy(data, raw_packet.buf, raw_packet.lest);
    data[raw_packet.lest + 1] = 0x0;

    printf("%s", data);

    free(data);
}

/**
 * @brief イーサネットを表示する
 * @param (packet) パケット
 */
void PrintEthernet(Packet *packet){
    char dhost[19];
    char shost[19];

    snprintf(dhost, sizeof(dhost), "%02x:%02x:%02x:%02x:%02x:%02x",
        packet -> eh -> ether_dhost[0],
        packet -> eh -> ether_dhost[1],
        packet -> eh -> ether_dhost[2],
        packet -> eh -> ether_dhost[3],
        packet -> eh -> ether_dhost[4],
        packet -> eh -> ether_dhost[5]
    );

    snprintf(shost, sizeof(shost), "%02x:%02x:%02x:%02x:%02x:%02x",
        packet -> eh -> ether_shost[0],
        packet -> eh -> ether_shost[1],
        packet -> eh -> ether_shost[2],
        packet -> eh -> ether_shost[3],
        packet -> eh -> ether_shost[4],
        packet -> eh -> ether_shost[5]
    );

    printf("-*-*-*-*- Ethernet -*-*-*-*-\n");
    printf("destionation : %s\n", dhost);
    printf("source       : %s\n", shost);
    printf("type         : %d\n\n", packet -> eh -> ether_type);
}

void PrintIP(Packet *packet){
    char saddr[15];
    char daddr[15];

    inet_ntop(AF_INET, &(packet -> ip -> saddr), saddr, sizeof(saddr));
    inet_ntop(AF_INET, &(packet -> ip -> daddr), daddr, sizeof(daddr));

    printf("-*-*-*-*-    IP    -*-*-*-*-\n");
    printf("version          : %d\n", packet -> ip -> version);
    printf("IP header length : %d\n", packet -> ip -> ihl);
    printf("type of service  : %d\n", packet -> ip -> tos);
    printf("total length     : %d\n", packet -> ip -> tot_len);
    printf("identification   : %d\n", packet -> ip -> id);
    printf("frag offset      : %d\n", packet -> ip -> frag_off);
    printf("time to live     : %d\n", packet -> ip -> ttl);
    printf("protocol         : %d\n", packet -> ip -> protocol);
    printf("checksum         : %d\n", packet -> ip -> check);
    printf("destionation     : %s\n", daddr);
    printf("source           : %s\n\n", saddr);
}

void PrintTCP(Packet *packet) {
    printf("-*-*-*-*-   TCP   -*-*-*-*-\n");

    printf("source port      :  %d\n", htons(packet -> tcp -> th_sport));
    printf("destination port :  %d\n", htons(packet -> tcp -> th_dport));
    printf("seq number       :  %d\n", htons(packet -> tcp -> th_seq));
    printf("ack number       :  %d\n", htons(packet -> tcp -> th_ack));

    printf("data offset      :  %d\n", htons(packet -> tcp -> th_off));
    printf("res              : x%x\n", htons(packet -> tcp -> th_x2));
    
    printf("flag             : x%x\n", htons(packet -> tcp -> th_flags));

    printf("window           :  %d\n", htons(packet -> tcp -> th_win));
    printf("check            : x%x\n", htons(packet -> tcp -> th_sum));
    printf("urg_ptr          : x%x\n", htons(packet -> tcp -> th_urp));
}

void PrintData(Packet *packet){
    printf("-*-*-*-*-   DATA   -*-*-*-*-\n");
    if (packet -> data_size <= 0) {
        return;
    }

    RawPacket raw_packet = {
        packet -> data,
        packet -> data_size
    };

    PrintString(raw_packet);
    printf("\n\n");
}

```

<<<

## TCPパケットを
## 送信してみる

>>>

### 手順
単体での送信はEthernet、IP、UDPと違いはない。  
しかし実際の通信では、複数のパケットにまたがって通信し、
通信の最初に3way-handshakeが行われる。

#### 1. パケットの作成　　　　　　
#### 2. 解析して構造体に落とし込む
#### 3. パケットの表示　　　　　　

>>>

### コード

client/src/tcp.c

```c
/**
 * @brief 実際のパケットの受取部
 * @param (soc) ソケット
 * @return 成功したら1, 失敗したら-1
 */
int Send(int soc){
    // 変数の宣言
    struct ether_header eh;
    
    int size;
    Packet packet;
    packet.eh = &eh;

    // シードをセット
    srand(time(NULL));

    // パケットの初期化
    // Data
    unsigned char data[] = "hi";
    packet.data = data;
    packet.data_size = sizeof(data);

    // Ethernet
    sprintf(eh.ether_dhost, "\x00\x00\x00\x00\x00\x00");
    sprintf(eh.ether_shost, "\x00\x00\x00\x00\x00\x00");
    eh.ether_type = (u_int16_t)8;
    
    // IP
    int over_eh_size =  
            + sizeof(struct iphdr) 
            + sizeof(struct tcphdr) 
            + sizeof(data);

    struct iphdr ip = {
        sizeof(struct iphdr) / 4,
        4,
        (u_int8_t)0,
        (u_int16_t)htons(over_eh_size),
        (u_int16_t)htons(rand() % 0x10000),
        (u_int16_t)htons(0b0100000000000000),// + (rand() % 0x100)),
        (u_int8_t)1,
        (u_int8_t)IPPROTO_TCP,
        (u_int16_t)0x00,
        (u_int32_t)0x00,
        (u_int32_t)0x00        
    };

    inet_pton(AF_INET, "127.0.0.1", &(ip.saddr));
    inet_pton(AF_INET, "127.0.0.1", &(ip.daddr));

    ip.check = checksum2((unsigned char *)&ip, sizeof(struct iphdr), NULL, 0);

    // tcp
    int offset = sizeof(struct tcphdr) / 4;

    struct tcphdr tcp = {
        (u_int16_t)htons(rand() % 0x50000),
        (u_int16_t)htons(8080),
        (u_int32_t)htons(0),
        (u_int32_t)0,
        (u_int8_t)0,
        (u_int8_t)htons(offset),
        (u_int8_t)TH_SYN,
        (u_int16_t)htons(500),
        (u_int16_t)0,
        (u_int16_t)0,
     };


    // 実体の生成
    GenerateEthernetPacket(&packet, &eh);
    AddIPHeader(&packet, &ip);
    AddTCPHeader(&packet, &tcp);
    AddData(&packet, data, sizeof(data));

     // チェックサム
    int len = ntohs(packet.ip -> tot_len) - packet.ip -> ihl * 4;
    tcp.check = checksum3(packet.ip, (unsigned char *)packet.tcp, len);

    // 表示
    printf("text:\n");
    PrintEthernet(&packet);
    PrintIP(&packet);
    PrintTCP(&packet);
    PrintData(&packet);

    printf("binary:\n");
    PrintRawEthernet(&packet);
    PrintRawIP(&packet);
    PrintRawTCP(&packet);
    PrintRawData(&packet);
    PrintRawPacket(&packet);

    // パケットの読み込み
    if((size = write(soc, packet.ptr, packet.size)) <= 0){
        // 失敗したらエラーを開く
        perror("write");
        return -1;
    }

    FreePacket(&packet);

    return 0;
}

```

>>>

### コード（パケットの作成）

lib/generate.c

```c
void GenerateEthernetPacket(Packet *packet, struct ether_header *eh) {
    size_t size = sizeof(struct ether_header);
    packet -> ptr = (unsigned char *)malloc(size);
    packet -> eh = (struct ether_header *)packet -> ptr;
    memcpy(packet -> eh, eh, sizeof(struct ether_header));
    packet -> size = sizeof(struct ether_header);
}

void AddIPHeader(Packet *packet, struct iphdr *ip) {
    size_t size = sizeof(struct iphdr);
    packet -> ptr = (unsigned char *)realloc(packet -> ptr, packet -> size + size);
    packet -> ip = (struct iphdr *)(packet -> ptr + packet -> size);
    memcpy(packet -> ip, ip, sizeof(struct iphdr));
    packet -> size = size + packet -> size;
}

void AddTCPHeader(Packet *packet, struct tcphdr *tcp) {
    size_t size = sizeof(struct tcphdr);
    packet -> ptr = (unsigned char *)realloc(packet -> ptr, packet -> size + size);
    packet -> tcp = (struct tcphdr *)(packet -> ptr + packet -> size);
    memcpy(packet -> tcp, tcp, sizeof(struct tcphdr));
    packet -> size = size + packet -> size;
}

void AddData(Packet *packet, unsigned char *data, size_t size) {
    packet -> ptr = (unsigned char *)realloc(packet -> ptr, packet -> size + size);
    packet -> data = (unsigned char *)(packet -> ptr + packet -> size);
    packet -> data_size = size;
    memcpy(packet -> data, data, size);
    packet -> size = size + packet -> size;
}

```

>>>

### メモリ開放
Ethernet、IP、UDPのときと同じ

lib/generate.c

```c
void FreePacket(Packet *packet) {
    free(packet -> ptr);
}
```


<<<

## 送信したTCPパケットを解析

>>>

### C言語だと

```c
// シードをセット
srand(time(NULL));

// パケットの初期化
// Data
unsigned char data[] = "hi";
packet.data = data;
packet.data_size = sizeof(data);

// Ethernet
sprintf(eh.ether_dhost, "\x00\x00\x00\x00\x00\x00");
sprintf(eh.ether_shost, "\x00\x00\x00\x00\x00\x00");
eh.ether_type = (u_int16_t)8;

// IP
int over_eh_size =  
        + sizeof(struct iphdr) 
        + sizeof(struct tcphdr) 
        + sizeof(data);

struct iphdr ip = {
    sizeof(struct iphdr) / 4,
    4,
    (u_int8_t)0,
    (u_int16_t)htons(over_eh_size),
    (u_int16_t)htons(rand() % 0x10000),
    (u_int16_t)htons(0b0100000000000000),// + (rand() % 0x100)),
    (u_int8_t)1,
    (u_int8_t)IPPROTO_TCP,
    (u_int16_t)0x00,
    (u_int32_t)0x00,
    (u_int32_t)0x00        
};

inet_pton(AF_INET, "127.0.0.1", &(ip.saddr));
inet_pton(AF_INET, "127.0.0.1", &(ip.daddr));

ip.check = checksum2((unsigned char *)&ip, sizeof(struct iphdr), NULL, 0);

// tcp
int offset = sizeof(struct tcphdr) / 4;

struct tcphdr tcp = {
    (u_int16_t)htons(rand() % 0x50000),
    (u_int16_t)htons(8080),
    (u_int32_t)htons(0),
    (u_int32_t)0,
    (u_int8_t)0,
    (u_int8_t)htons(offset),
    (u_int8_t)TH_SYN,
    (u_int16_t)htons(500),
    (u_int16_t)0,
    (u_int16_t)0,
 };


// 実体の生成
GenerateEthernetPacket(&packet, &eh);
AddIPHeader(&packet, &ip);
AddTCPHeader(&packet, &tcp);
AddData(&packet, data, sizeof(data));

 // チェックサム
int len = ntohs(packet.ip -> tot_len) - packet.ip -> ihl * 4;
tcp.check = checksum3(packet.ip, (unsigned char *)packet.tcp, len);


```

>>>

### Ethernetのフレーム
前回と変わらず

| 名前 | 値| 詳細 |
|---|---|---|
| 宛先MACアドレス | 00:00:00:00:00:00 | 宛先のMACアドレス |
| 送信元MACアドレス | 00:00:00:00:00:00 | 送信元MACアドレス |
| タイプ | 8 | 上位プロトコルはIP |

>>>

### IPのパケット

| 名前 | 値 | 詳細 |
|---|---|---|
| version | 4 | IPv4 |
| ihl | iphdrのサイズ / 4 | optionはなし |
| tos | 0 | パケットの優先順位 |
| tot_len | sizeof(ip+tcp+data) | 各サイズの和、※ |

※リトルエンディアン

>>>

### IPのパケット

| 名前 | 値 | 詳細 |
|---|---|---|
| id | ランダム | ※ |
| frag_off | 0b010000000000000000000XX | Don't Fragment |
| ttl | 1 | 1回のみ経由可能 |

※リトルエンディアン

>>>

### IPのパケット

| 名前 | 値 | 詳細 |
|---|---|---|
| protocol | 17 | 上位プロトコルはTCP |
| check | チェックサム | チェックサム |
| saddr | 127.0.0.1 | 送信元IPアドレス |
| daddr | 127.0.0.1 | 送信先IPアドレス |

※リトルエンディアン

>>>

### TCPのパケット

| 名前 | 値 | 詳細 |
|---|---|---|
| th_sport | ランダム | 送信元port |
| th_dport | 8080 | 宛先port |
| th_seq | 0 | シーケンス番号 |

※リトルエンディアン

>>>

### TCPのパケット

| 名前 | 値 | 詳細 |
|---|---|---|
| th_ack | 0 | ※、確認応答番号 |
| th_off | tcpのヘッダサイズ / 4 | オフセット |
| th_x2 | 0 | 未使用 |

>>>

### TCPのパケット

| 名前 | 値 | 詳細 |
|---|---|---|
| th_flags | TH_SYN | SYNパケット |
| th_win | 500 | ウィンドウサイズ |
| th_sum | チェックサム | チェックサム |
| th_urp | 0 | 緊急情報のポインタ |

>>>

### WIRESHARKでみる

![](./img/tcp.png)

>>>

### WIRESHARKでみる

![](./img/tcp1.png)

<<<

## 考察・感想

>>>

### 考察

* IPアドレスや、MACアドレスは自己で変更できる
  * 認証等に使いたい場合は慎重に

>>>

### 感想

* バイナリ扱うのにやはりC言語強いなと…
* 今回の勉強会でそれなりにハードルが下がったと思うので、是非興味があれば自作パケットに取り組んでいただきたい！

<<<

## 補足・参考

>>>

### 補足

使用した構造体は、一部省略しています。

>>>

udphdr

```c
/* Copyright (C) 1991-2018 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * Copyright (C) 1982, 1986 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifndef __NETINET_UDP_H
#define __NETINET_UDP_H    1

#include <sys/types.h>
#include <stdint.h>

/* UDP header as specified by RFC 768, August 1980. */

struct udphdr
{
  __extension__ union
  {
    struct
    {
      uint16_t uh_sport;	/* source port */
      uint16_t uh_dport;	/* destination port */
      uint16_t uh_ulen;		/* udp length */
      uint16_t uh_sum;		/* udp checksum */
    };
    struct
    {
      uint16_t source;
      uint16_t dest;
      uint16_t len;
      uint16_t check;
    };
  };
};

/* UDP socket options */
#define UDP_CORK	1	/* Never send partially complete segments.  */
#define UDP_ENCAP	100	/* Set the socket to accept
				   encapsulated packets.  */
#define UDP_NO_CHECK6_TX 101	/* Disable sending checksum for UDP
				   over IPv6.  */
#define UDP_NO_CHECK6_RX 102	/* Disable accepting checksum for UDP
				   over IPv6.  */

/* UDP encapsulation types */
#define UDP_ENCAP_ESPINUDP_NON_IKE 1	/* draft-ietf-ipsec-nat-t-ike-00/01 */
#define UDP_ENCAP_ESPINUDP	2	/* draft-ietf-ipsec-udp-encaps-06 */
#define UDP_ENCAP_L2TPINUDP	3	/* rfc2661 */
#define UDP_ENCAP_GTP0		4	/* GSM TS 09.60 */
#define UDP_ENCAP_GTP1U		5	/* 3GPP TS 29.060 */

#define SOL_UDP            17      /* sockopt level for UDP */

#endif /* netinet/udp.h */

```


>>>

tcphdr

```c
/*
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)tcp.h	8.1 (Berkeley) 6/10/93
 */

#ifndef _NETINET_TCP_H
#define _NETINET_TCP_H	1

#include <features.h>

/*
 * User-settable options (used with setsockopt).
 */
#define	TCP_NODELAY		 1  /* Don't delay send to coalesce packets  */
#define	TCP_MAXSEG		 2  /* Set maximum segment size  */
#define TCP_CORK		 3  /* Control sending of partial frames  */
#define TCP_KEEPIDLE		 4  /* Start keeplives after this period */
#define TCP_KEEPINTVL		 5  /* Interval between keepalives */
#define TCP_KEEPCNT		 6  /* Number of keepalives before death */
#define TCP_SYNCNT		 7  /* Number of SYN retransmits */
#define TCP_LINGER2		 8  /* Life time of orphaned FIN-WAIT-2 state */
#define TCP_DEFER_ACCEPT	 9  /* Wake up listener only when data arrive */
#define TCP_WINDOW_CLAMP	 10 /* Bound advertised window */
#define TCP_INFO		 11 /* Information about this connection. */
#define	TCP_QUICKACK		 12 /* Bock/reenable quick ACKs.  */
#define TCP_CONGESTION		 13 /* Congestion control algorithm.  */
#define TCP_MD5SIG		 14 /* TCP MD5 Signature (RFC2385) */
#define TCP_COOKIE_TRANSACTIONS	 15 /* TCP Cookie Transactions */
#define TCP_THIN_LINEAR_TIMEOUTS 16 /* Use linear timeouts for thin streams*/
#define TCP_THIN_DUPACK		 17 /* Fast retrans. after 1 dupack */
#define TCP_USER_TIMEOUT	 18 /* How long for loss retry before timeout */
#define TCP_REPAIR		 19 /* TCP sock is under repair right now */
#define TCP_REPAIR_QUEUE	 20 /* Set TCP queue to repair */
#define TCP_QUEUE_SEQ		 21 /* Set sequence number of repaired queue. */
#define TCP_REPAIR_OPTIONS	 22 /* Repair TCP connection options */
#define TCP_FASTOPEN		 23 /* Enable FastOpen on listeners */
#define TCP_TIMESTAMP		 24 /* TCP time stamp */
#define TCP_NOTSENT_LOWAT	 25 /* Limit number of unsent bytes in
				       write queue.  */
#define TCP_CC_INFO		 26 /* Get Congestion Control
				       (optional) info.  */
#define TCP_SAVE_SYN		 27 /* Record SYN headers for new
				       connections.  */
#define TCP_SAVED_SYN		 28 /* Get SYN headers recorded for
				       connection.  */
#define TCP_REPAIR_WINDOW	 29 /* Get/set window parameters.  */
#define TCP_FASTOPEN_CONNECT	 30 /* Attempt FastOpen with connect.  */
#define TCP_ULP			 31 /* Attach a ULP to a TCP connection.  */
#define TCP_MD5SIG_EXT		 32 /* TCP MD5 Signature with extensions.  */
#define TCP_FASTOPEN_KEY	 33 /* Set the key for Fast Open (cookie).  */
#define TCP_FASTOPEN_NO_COOKIE	 34 /* Enable TFO without a TFO cookie.  */

#ifdef __USE_MISC
# include <sys/types.h>
# include <sys/socket.h>
# include <stdint.h>

typedef	uint32_t tcp_seq;
/*
 * TCP header.
 * Per RFC 793, September, 1981.
 */
struct tcphdr
  {
    __extension__ union
    {
      struct
      {
	uint16_t th_sport;	/* source port */
	uint16_t th_dport;	/* destination port */
	tcp_seq th_seq;		/* sequence number */
	tcp_seq th_ack;		/* acknowledgement number */
# if __BYTE_ORDER == __LITTLE_ENDIAN
	uint8_t th_x2:4;	/* (unused) */
	uint8_t th_off:4;	/* data offset */
# endif
# if __BYTE_ORDER == __BIG_ENDIAN
	uint8_t th_off:4;	/* data offset */
	uint8_t th_x2:4;	/* (unused) */
# endif
	uint8_t th_flags;
# define TH_FIN	0x01
# define TH_SYN	0x02
# define TH_RST	0x04
# define TH_PUSH	0x08
# define TH_ACK	0x10
# define TH_URG	0x20
	uint16_t th_win;	/* window */
	uint16_t th_sum;	/* checksum */
	uint16_t th_urp;	/* urgent pointer */
      };
      struct
      {
	uint16_t source;
	uint16_t dest;
	uint32_t seq;
	uint32_t ack_seq;
# if __BYTE_ORDER == __LITTLE_ENDIAN
	uint16_t res1:4;
	uint16_t doff:4;
	uint16_t fin:1;
	uint16_t syn:1;
	uint16_t rst:1;
	uint16_t psh:1;
	uint16_t ack:1;
	uint16_t urg:1;
	uint16_t res2:2;
# elif __BYTE_ORDER == __BIG_ENDIAN
	uint16_t doff:4;
	uint16_t res1:4;
	uint16_t res2:2;
	uint16_t urg:1;
	uint16_t ack:1;
	uint16_t psh:1;
	uint16_t rst:1;
	uint16_t syn:1;
	uint16_t fin:1;
# else
#  error "Adjust your <bits/endian.h> defines"
# endif
	uint16_t window;
	uint16_t check;
	uint16_t urg_ptr;
      };
    };
};

enum
{
  TCP_ESTABLISHED = 1,
  TCP_SYN_SENT,
  TCP_SYN_RECV,
  TCP_FIN_WAIT1,
  TCP_FIN_WAIT2,
  TCP_TIME_WAIT,
  TCP_CLOSE,
  TCP_CLOSE_WAIT,
  TCP_LAST_ACK,
  TCP_LISTEN,
  TCP_CLOSING   /* now a valid state */
};

# define TCPOPT_EOL		0
# define TCPOPT_NOP		1
# define TCPOPT_MAXSEG		2
# define TCPOLEN_MAXSEG		4
# define TCPOPT_WINDOW		3
# define TCPOLEN_WINDOW		3
# define TCPOPT_SACK_PERMITTED	4		/* Experimental */
# define TCPOLEN_SACK_PERMITTED	2
# define TCPOPT_SACK		5		/* Experimental */
# define TCPOPT_TIMESTAMP	8
# define TCPOLEN_TIMESTAMP	10
# define TCPOLEN_TSTAMP_APPA	(TCPOLEN_TIMESTAMP+2) /* appendix A */

# define TCPOPT_TSTAMP_HDR	\
    (TCPOPT_NOP<<24|TCPOPT_NOP<<16|TCPOPT_TIMESTAMP<<8|TCPOLEN_TIMESTAMP)

/*
 * Default maximum segment size for TCP.
 * With an IP MSS of 576, this is 536,
 * but 512 is probably more convenient.
 * This should be defined as MIN(512, IP_MSS - sizeof (struct tcpiphdr)).
 */
# define TCP_MSS	512

# define TCP_MAXWIN	65535	/* largest value for (unscaled) window */

# define TCP_MAX_WINSHIFT	14	/* maximum window shift */

# define SOL_TCP		6	/* TCP level */


# define TCPI_OPT_TIMESTAMPS	1
# define TCPI_OPT_SACK		2
# define TCPI_OPT_WSCALE	4
# define TCPI_OPT_ECN		8  /* ECN was negociated at TCP session init */
# define TCPI_OPT_ECN_SEEN	16 /* we received at least one packet with ECT */
# define TCPI_OPT_SYN_DATA	32 /* SYN-ACK acked data in SYN sent or rcvd */

/* Values for tcpi_state.  */
enum tcp_ca_state
{
  TCP_CA_Open = 0,
  TCP_CA_Disorder = 1,
  TCP_CA_CWR = 2,
  TCP_CA_Recovery = 3,
  TCP_CA_Loss = 4
};

struct tcp_info
{
  uint8_t	tcpi_state;
  uint8_t	tcpi_ca_state;
  uint8_t	tcpi_retransmits;
  uint8_t	tcpi_probes;
  uint8_t	tcpi_backoff;
  uint8_t	tcpi_options;
  uint8_t	tcpi_snd_wscale : 4, tcpi_rcv_wscale : 4;

  uint32_t	tcpi_rto;
  uint32_t	tcpi_ato;
  uint32_t	tcpi_snd_mss;
  uint32_t	tcpi_rcv_mss;

  uint32_t	tcpi_unacked;
  uint32_t	tcpi_sacked;
  uint32_t	tcpi_lost;
  uint32_t	tcpi_retrans;
  uint32_t	tcpi_fackets;

  /* Times. */
  uint32_t	tcpi_last_data_sent;
  uint32_t	tcpi_last_ack_sent;	/* Not remembered, sorry.  */
  uint32_t	tcpi_last_data_recv;
  uint32_t	tcpi_last_ack_recv;

  /* Metrics. */
  uint32_t	tcpi_pmtu;
  uint32_t	tcpi_rcv_ssthresh;
  uint32_t	tcpi_rtt;
  uint32_t	tcpi_rttvar;
  uint32_t	tcpi_snd_ssthresh;
  uint32_t	tcpi_snd_cwnd;
  uint32_t	tcpi_advmss;
  uint32_t	tcpi_reordering;

  uint32_t	tcpi_rcv_rtt;
  uint32_t	tcpi_rcv_space;

  uint32_t	tcpi_total_retrans;
};


/* For TCP_MD5SIG socket option.  */
#define TCP_MD5SIG_MAXKEYLEN	80

/* tcp_md5sig extension flags for TCP_MD5SIG_EXT.  */
#define TCP_MD5SIG_FLAG_PREFIX	1 /* Address prefix length.  */

struct tcp_md5sig
{
  struct sockaddr_storage tcpm_addr;		/* Address associated.  */
  uint8_t	tcpm_flags;			/* Extension flags.  */
  uint8_t	tcpm_prefixlen;			/* Address prefix.  */
  uint16_t	tcpm_keylen;			/* Key length.  */
  uint32_t	__tcpm_pad;			/* Zero.  */
  uint8_t	tcpm_key[TCP_MD5SIG_MAXKEYLEN];	/* Key (binary).  */
};

/* For socket repair options.  */
struct tcp_repair_opt
{
  uint32_t	opt_code;
  uint32_t	opt_val;
};

/* Queue to repair, for TCP_REPAIR_QUEUE.  */
enum
{
  TCP_NO_QUEUE,
  TCP_RECV_QUEUE,
  TCP_SEND_QUEUE,
  TCP_QUEUES_NR,
};

/* For cookie transactions socket options.  */
#define TCP_COOKIE_MIN		8		/*  64-bits */
#define TCP_COOKIE_MAX		16		/* 128-bits */
#define TCP_COOKIE_PAIR_SIZE	(2*TCP_COOKIE_MAX)

/* Flags for both getsockopt and setsockopt */
#define TCP_COOKIE_IN_ALWAYS	(1 << 0)	/* Discard SYN without cookie */
#define TCP_COOKIE_OUT_NEVER	(1 << 1)	/* Prohibit outgoing cookies,
						 * supercedes everything. */

/* Flags for getsockopt */
#define TCP_S_DATA_IN		(1 << 2)	/* Was data received? */
#define TCP_S_DATA_OUT		(1 << 3)	/* Was data sent? */

#define TCP_MSS_DEFAULT		 536U	/* IPv4 (RFC1122, RFC2581) */
#define TCP_MSS_DESIRED		1220U	/* IPv6 (tunneled), EDNS0 (RFC3226) */

struct tcp_cookie_transactions
{
  uint16_t	tcpct_flags;
  uint8_t	__tcpct_pad1;
  uint8_t	tcpct_cookie_desired;
  uint16_t	tcpct_s_data_desired;
  uint16_t	tcpct_used;
  uint8_t	tcpct_value[TCP_MSS_DEFAULT];
};

/* For use with TCP_REPAIR_WINDOW.  */
struct tcp_repair_window
{
  uint32_t snd_wl1;
  uint32_t snd_wnd;
  uint32_t max_window;
  uint32_t rcv_wnd;
  uint32_t rcv_wup;
};

#endif /* Misc.  */

#endif /* netinet/tcp.h */

```

>>>

### 参考

* ルーター自作でわかるパケットの流れ、小俣 光之、
  * netutils.c
  * checksum.c
* CでEtherフレームを理解する
  * https://qiita.com/Ki4mTaria/items/0f3c5d306662e0bdf7cf


>>>

### 参考

* CでIPヘッダを理解する
  * https://qiita.com/Ki4mTaria/items/188df29ca26dbdc7887c
* パケットを自前で生成してTCP接続する
  * https://qiita.com/marufeuille/items/81f323a52a6fd3bd530c
*  ヘッダ構造体メモ
  * http://d.hatena.ne.jp/chipa34/20081217/1229479548


<<<

# 最後に

>>>

### 今回勉強したパケットたちを
## `完全理解`　
### して頂けたでしょうか？

>>>

## 雰囲気だけでも掴んで帰って
## 頂けると嬉しいです！

>>>

#### （ちなみに最初に表示したwiresharkの
#### 画像は、最後にキャプチャした
#### TCPのパケットと同じですよ！）

<<<

## よいパケットマンライフを！

                </section>
            </div>
        </div>

        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>

        <script>
            // More info about config & dependencies:
            // - https://github.com/hakimel/reveal.js#configuration
            // - https://github.com/hakimel/reveal.js#dependencies
            Reveal.initialize({
                history: true,
                dependencies: [
                    { src: 'plugin/markdown/marked.js' },
                    { src: 'plugin/markdown/markdown.js' },
                    { src: 'plugin/notes/notes.js', async: true },
                    { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
                ]
            });
        </script>
    </body>
</html>

