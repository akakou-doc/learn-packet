
<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

        <title>reveal.js</title>

        <link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/black.css">

        <!-- Theme used for syntax highlighting of code -->
        <link rel="stylesheet" href="lib/css/zenburn.css">

        <!-- Printing and PDF exports -->
        <script>
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>
    </head>
    <body>
        <style>
        img {
            border-style:none;
        }
        </style>

        <div class="reveal">
            <div class="slides">
                <section 
                    data-markdown
                    data-separator="^\n<<<$"
                    data-separator-vertical="^\n>>>$">

# パケットを作ろう！
#### 作って学ぶパケット入門

<<<

## 自己紹介

>>>

## あかこう
@akakou_py 

セキュリティが好き。

![](https://pbs.twimg.com/profile_images/811407669894385664/8dQkt863_400x400.jpg)

<<<

## 皆さんは

>>>

## wireshark
## 覗いたことありますか？

>>>

### wireshark
* ネットワークプロトコルアナライザ
* これを使うとパケットが見れる

![](https://cdn-ssl-devio-img.classmethod.jp/wp-content/uploads/2014/08/wireshark_icon.jpg)

>>>

### 初めてwiresharkと出会った僕
「へぇ〜これを使うとパケットが見えるんだぁ〜、すごいなぁ〜」

>>>

# 画面

>>>

### 確かにパケットが見える
## しかし**読めるとは言ってない**

>>>

パケットを読むには
パケットの知識が必要

>>>

#### そこで僕は様々な手段を試しました

* ### 読書
* ### 自作ルータ
* ### 自作パケット

>>>

* ## 自作ルータ
* ## 自作パケット

>>>

* # 自作パケット

>>>

### 自作パケットすごい良かった

* そのパケット持つ値を理解していかないと次に進まない感が良い
* L3、L4のパケットの内容に関してはほとんど理解できる

>>>

### でもこんなところが悪かった

* #### とても辛かった
* #### ある程度知識がないと進まない 


>>>

## 今回は

### 基礎知識をつけながら
### （楽しく？）

パケットを自作を通して、  
パケットについて解説していきたいと思います。

>>>

## 早速やっていきましょう！
![](https://emojipedia-us.s3.amazonaws.com/thumbs/160/apple/129/thumbs-up-sign_1f44d.png)


<<<

## 基礎知識を学ぶ

>>>

### パケットを読むにも、作るにも
### TCP/IPに関する知識が必要です。


>>>
### パケットを詳細に理解する前に、
### TCP/IPについて
### 簡単に復習しましょう。

<<<

## Protocol

>>>

### Protocol（プロトコル）とは

#### 通信をする際のルールや
#### 決まりごと（のようなもの）。  

>>>
### 例を上げるならば
HTTP, FTP, TCP, UDP, IP, IPv6, ARP, Ethernet, IEEE 802.11, PPP

<<<
## OSI参照モデル

>>>
### OSI参照モデルとは

通信機能を階層構造に分割したもの。  
ISOによって制定された。  
通信機能を **7つ** に分けて制定している。  

>>>
### レイヤー構成

<div style="text-align:left;">

##### 1層 物理層
##### 2層 データリンク層
##### 3層 インターネット層
##### 4層 トランスポート層
##### 5層 セッション層
##### 6層 プレゼンテーション層
##### 7層 アプリケーション層

</div>

>>>
### 1. 物理層
物理的な接続等を取り決める。

例： 電話線・UTP  
※今回物理層は扱いません

>>>
### 2. データリンク層
直接繋がれている端末同士のやり取り等を取り決める。

例： **Ethernet**、IEEE 802.11、PPPoE

>>>
### 3. インターネット層
ネットワーク同士の通信。  
通信経路の選択（ルーティング）

例： **IPv4**、IPv6、ARP

>>>
### 4. トランスポート層
ネットワークの端から端までの通信のやり取りを行う。
再送処理や、エラー訂正等を行い、通信の信頼性を担保する。
（担保しないものもある。）

例： **TCP**、**UDP**

>>>
### 5. セッション層
通信しているプログラム間の通信の開始、  
終了等の手順を決めている。

例： TLS(?)

>>>
### 6. プレゼンテーション層
データの表現方法に関するプロトコル。

例：SMTP、FTP

>>>
### 7. アプリケーション層
具体的なサービス提供に関するプロトコル。

例：**HTTP**、DHCP、SMTP、SNMP、SMB、FTP

>>>

### レイヤーごとに具体的なプロトコルのパケットを見ていきましょう。

<<<

## その前に

>>>

#### ここからパケットを飛ばしながら、解説します。
#### まずパケットの送受信について調べましょう。 

>>>

### raw_socket
生のパケット（バイナリ）を  
送受信できるソケット。

>>>

### raw_socketの準備の仕方

lib/netutils.h InitRawSocket

>>>

### 手順

1. socket関数を使って、ソケットを取得
2. ioctl関数を使って、
3. bind関数を使ってバインド（）する。

>>>

### コード(Initraw_socket)

```c
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <linux/if.h>
#include <net/ethernet.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <netinet/udp.h>
#include <netpacket/packet.h>
#include <netinet/if_ether.h>


/**
 * @brief RAWソケットを準備する
 * @param (device) ネットワークインターフェース名
 * @return socketのディスクリプタ
 */
int InitRawSocket(char *device) {
    // ネットワークデバイスを設定する際に
    // ioctl というシステムコール時に渡して
    // 設定や情報取得を行うための構造体
    struct ifreq ifreq;
    // デバイスに依存しない物理層のアドレスを格納するプロトコル
    struct sockaddr_ll sa;
    // ソケット(データリンク層を扱うディスクリプタ)
    int soc;

    // ソケットを用意
    // 第一引数 : プロトコルファミリ→ PF_PACKET(L2)
    // 第二引数 : 通信方式→ SOCK_RAW
    // 第三引数 : データリンク層→ ETH_P_IP (IPパケットのみ)
    if((soc = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_IP))) < 0) {
        fprintf(stderr, "[init] socket error\n");
        return -1;
    }

    // ifreqをゼロ初期化
    memset(&ifreq, 0, sizeof(struct ifreq));
    // ネットワークデバイス名をifreq.ifr_nameにコピー
    strncpy(ifreq.ifr_name, device, sizeof(ifreq.ifr_name) -1);
    // インターフェース名に対応した
    // インターフェースのインデックスを取得
    // 第一引数 : オープンされたディスクリプタ
    // 第二引数 : デバイスドライバに対する個々の操作に割り当てられた番→ SIOCGIFINDEX
    // インデックスの流し先→ ifreq
    if(ioctl(soc, SIOCGIFINDEX, &ifreq) < 0) {
        fprintf(stderr, "[init] ioctl error\n");
        close(soc);
        return -1;
    }

    // sa.sll_family (デバイスに依存しない物理層の構造体のプロトコルファミリ部)に、
    // PF_PACKET (L2のプロトコルファミリ)を設定
    sa.sll_family = PF_PACKET;
    // sa.sll_protocol (デバイスに依存しない物理層の構造体のプロトコル部)に、
    // ホストバイトオーダからネットワークバイトオーダに変換した、
    // IPパケットのみを取得することを示したデータを格納
    sa.sll_protocol = htons(ETH_P_IP);
    // ifreq.ifr_ifindex に格納されたインターフェース番号をsa.sll_ifindexに設定
    sa.sll_ifindex = ifreq.ifr_ifindex;

    // 第一引数で指定されたディスクリプターで参照されるソケットに、
    // 第二引数で指定されたアドレスを割り当てる。
    // 第一引数 : 元のディスクリプタ
    // 第二引数 : 割り当て先
    // 第三引数 : 第二引数の指す構造体のサイズ
    if(bind(soc, (struct sockaddr *)&sa, sizeof(sa)) < 0) {
        fprintf(stderr, "[init] bind error\n");
        close(soc);
        return -1;
    }

    return soc;
}

```

>>>

### パケットの送信

write関数を使う

```c
/**
 * @param (soc) ソケット
 * @param (ptr) パケットのポインタ
 * @param (size) パケットのサイズ
 */
if(size = write(soc, ptr, size) <= 0){
    // 失敗したらエラーを開く
    perror("write");
    return -1;
}

```

>>>

### パケットの受信

read関数を使う

```c
/**
 * @param (soc) ソケット
 * @param (buf) 読み込むパケットの保存先のポインタ
 * @param (size) bufのサイズ
 */

// パケットの読み込み
if(size = read(soc, buf, sizeof(buf)) <= 0){
    // 失敗したらエラーを開く
    perror("read");
    return -1;
}

```

<<<

## Ethernet

>>>

### Ethernetとは

有線のLANで最も使用されている技術規格。
OSI参照モデルの下位2つの層である物理層とデータリンク層に関して規定している。

>>>

### イーサネットのフレーム（パケット）

| 名前 | サイズ | 詳細 |
|---|---|---|
| ブリアンブル | 8 | フレームの始まりを合図する |
| 宛先MACアドレス | 6 | 宛先のMACアドレス |
| 送信元MACアドレス | 6 | 送信元MACアドレス |


>>>

### 続き

| 名前 | サイズ | 詳細 |
|---|---|---|
| タイプ | 2 | 上位プロトコルの番号 |
| データ | 46〜1500 | データだよ |
| FCS | 4 | チェックサム的ななつ |


>>>

### 構造体
linux/if_ehter.h

```c
 struct ethhdr
 {
    unsigned char   h_dest[ETH_ALEN];   /* destination eth addr */
    unsigned char   h_source[ETH_ALEN]; /* source ether addr    */
    unsigned short  h_proto;        /* packet type ID field */
 };

```

raw_socket側では宛先MACアドレス、  
送信元MACアドレス、タイプしか扱わない

<<<

## Ethernetパケットを
## 送信してみる

>>>

### 手順

#### 1. イーサネットパケットの用意
#### 2. パケットの用意（後に説明）
#### 3. 送信
#### 4. パケットの表示

>>>

### コード

client/src/ethernet.c

```c
int Send(int soc){
    // 変数の宣言
    Packet packet;
    int size;
    struct ether_header eh;

    // パケットの初期化
    sprintf(eh.ether_dhost, "\x00\x00\x00\x00\x00\x00");
    sprintf(eh.ether_shost, "\x00\x00\x00\x00\x00\x00");
    eh.ether_type = (u_int16_t)8;

    GenerateEthernetPacket(&packet, &eh);

    PrintEthernet(&packet);
    PrintRawPacket(&packet);

    // パケットの読み込み
    if((size = write(soc, packet.ptr, packet.size)) <= 0){
        // 失敗したらエラーを開く
        perror("write");
        return -1;
    }

    // パケットの開放
    FreePacket(&packet);

    return 0;
}

```

>>>

### コード（ヒープへの移動）
ether_headerをヒープに移動します。  
（理由は後に説明）

```c
void GenerateEthernetPacket(Packet *packet, struct ether_header *eh) {
    size_t size = sizeof(struct ether_header);
    packet -> ptr = (unsigned char *)malloc(size);
    packet -> eh = (struct ether_header *)packet -> ptr;
    memcpy(packet -> eh, eh, sizeof(struct ether_header));
    packet -> size = sizeof(struct ether_header);
}

```

>>>

### パケット表示

```c
void PrintData(Packet *packet){
    printf("-*-*-*-*-   DATA   -*-*-*-*-\n");
    if (packet -> data_size <= 0) {
        return;
    }

    RawPacket raw_packet = {
        packet -> data,
        packet -> data_size
    };

    PrintString(raw_packet);
    printf("\n\n");
}

```

>>>

### パケット表示

```c
/**
 * @brief イーサネットを表示する
 * @param (packet) パケット
 */
void PrintEthernet(Packet *packet){
    char dhost[19];
    char shost[19];

    snprintf(dhost, sizeof(dhost), "%02x:%02x:%02x:%02x:%02x:%02x",
        packet -> eh -> ether_dhost[0],
        packet -> eh -> ether_dhost[1],
        packet -> eh -> ether_dhost[2],
        packet -> eh -> ether_dhost[3],
        packet -> eh -> ether_dhost[4],
        packet -> eh -> ether_dhost[5]
    );

    snprintf(shost, sizeof(shost), "%02x:%02x:%02x:%02x:%02x:%02x",
        packet -> eh -> ether_shost[0],
        packet -> eh -> ether_shost[1],
        packet -> eh -> ether_shost[2],
        packet -> eh -> ether_shost[3],
        packet -> eh -> ether_shost[4],
        packet -> eh -> ether_shost[5]
    );

    printf("-*-*-*-*- Ethernet -*-*-*-*-\n");
    printf("destionation : %s\n", dhost);
    printf("source       : %s\n", shost);
    printf("type         : %d\n\n", packet -> eh -> ether_type);
}

```

<<<
 

                </section>
            </div>
        </div>

        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>

        <script>
            // More info about config & dependencies:
            // - https://github.com/hakimel/reveal.js#configuration
            // - https://github.com/hakimel/reveal.js#dependencies
            Reveal.initialize({
                history: true,
                dependencies: [
                    { src: 'plugin/markdown/marked.js' },
                    { src: 'plugin/markdown/markdown.js' },
                    { src: 'plugin/notes/notes.js', async: true },
                    { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
                ]
            });
        </script>
    </body>
</html>

